/**
 * Inter.
 * Version: 1.2.13
 * 2021 - 2022 -  by Denis Power.
 * https://github.com/interjs/inter
 * A Javascript framework to build interactive frontend applications.
 * 
 * 
 */

!function(){function e(e){return"[object Object]"==Object.prototype.toString.call(e)}function t(e){return Array.isArray(e)}function n(e){return"number"==typeof+e}function r(e){return"function"==typeof e}function o(e){return"number"==typeof e||"boolean"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e?typeof e:Object.type(e)}function s(e){return e in this}function a(e){return e instanceof HTMLElement}function i(e){return/{\s*.*\s*}/.test(e)}function l(e){return!(void 0==e)}function c(e){return 1==e||0==e}function u(e){return e instanceof HTMLInputElement||e instanceof HTMLTextAreaElement}function d(e){if("production"==Q.status)return!1;throw new SyntaxError(e)}function h(e){if("production"!=Q.status&&"development"==Q.status)throw new TypeError(e)}function f(e){if(document instanceof Document){const t=document.getElementById(e);if(void 0!=t)return t;d(`\n    There is not an element by id "${e}" on the document.\n    `)}}function p(e){"production"!=Q.status&&console.warn(e)}function g(e){return document instanceof Document?document.createTextNode(e):void 0}function m(e,t){return void 0!=e&&(F(e)?e.hasAttribute(t):void 0)}function y(e){return document instanceof Document?document.createElement(e):void 0}function b(e,t,n){return a(e)?e.setAttribute(t,n):void 0}function x(e,t){return a(e)?e.getAttribute(t):void 0}function O(e){return 1==e}function j(e,t){if("_events"in t)for(let e in t._events)t[e]=void 0;for(let[n,r]of Object.entries(e._events))t[n]=r}function w(e){return e in document.body.style}function T(e){return e in HTMLElement.prototype}function E(e){return"a"==de.call(e.nodeName)||"button"==de.call(e.nodeName)}function C(){var e;if("[object Window]"==(e=this,Object.prototype.toString.apply(e,void 0)))return;const t=this.getElementsByTagName("*");for(let e of t)E(e)&&m(e,"setPath")?(e.setpath=x(e,"setPath"),e.removeAttribute("setPath"),e.onclick=function(e){e.preventDefault();const t=this.setpath;te.test(t)?me.setPath(t):d("\n                A valid pathName must start with /.\n                ")}):E(e)&&m(e,"useHash")&&(e.setpath=x(e,"useHash"),e.removeAttribute("useHash"),e.onclick=function(e){e.preventDefault();const t=this.usehash;te.test(t)?me.useHash(t):d("\n                A valid pathName must start with /.\n                ")})}function N(e,t){return!Object.is(e,t)}function R(){}function A(e){return/^\[object HTML+(:?[A-Z]+)+Element\]$/i.test(e)}function $(e){return 0==e.length}function P(){}function S(){let e=null;var t=document.getElementsByTagName("*");for(let n=0;n<t.length;n++)if(m(t[n],"handleValue"))if(u(t[n])){m(t[n],"in")||d("\n                in attribute is required.\n                ");const r=t[n].getAttribute("handleValue"),o=oe.create(null);let s=f(x(t[n],"in"));if(s.getTextNodes.length>0)for(let e of s.getTextNodes){const s=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g");if(s.test(e.textContent)){const r=e.textContent.replace(s,"");o.push({target:e,text:e.textContent,input:t[n]}),e.textContent=r}}s=s.getElementsByTagName("*");for(let e=0;e<s.length;e++){const a=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g");if(a.test(s[e].textContent)){let i=s[e];if(_(i)){let e=i.childNodes;for(let s of e){const e=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g");if(e.test(s.textContent)){const r=s.textContent.replace(e,"");o.push({target:s,text:s.textContent,input:t[n]}),s.textContent=r}}}else{const e=i.textContent.replace(a,"");o.push({target:i,text:i.textContent,input:t[n]}),i.textContent=e}}}const a=x(t[n],"in");e=a,ye.justRegistered(a)?oe.shareItens(o,ye.handler[a]):(ye.handler[a]=oe.create(null),oe.shareItens(o,ye.handler[a]),oe.destroy(o)),t[n].oninput=(e=>{let t=ye.handler[a];for(let n of t){const{target:t,text:o}=n,s=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g");if(s.test(o)){let n=o.replace(s,e.target.value);t.textContent=n}}})}else d("\n            Really? handleValue must be only setted in elements that recieves the value attribute.\n            like <input> and <textarea></textarea>.\n            ");je.fire(`handler${e}`)}function I(){}function L(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0})}function H(e){return 0==Object.keys(e).length}function k(){}function _(e){return e.getElementsByTagName("*").length>0}function Y(e){return{length:a(e)?e.getElementsByTagName("*").length:0}}function D(e){return a(e)?e.getElementsByTagName("*"):oe.create(null)}function B(e,t,n,r){let o=t.children[n];if(M(o,e))return t.replaceChild(e,o),!1;if(Y(o).length!==Y(e).length)return void t.replaceChild(e,o);let s=D(t.children[n]);const a=D(e);if(U(o,e))t.replaceChild(e,o);else if(s.length>0&&a.length>0){let e=Array.from(a);for(let n=0;n<e.length;n++){if(M(e[n],s[n])){let a=s[n];if(W(s[n])&&n+1+Y(s[n]).length==e.length){t.replaceChild(r()[0],o);break}if(a.parentNode.replaceChild(e[n],a),0>=a.children.length)continue;n+=a.getElementsByTagName("*").length}if(l(s[n])&&l(e[n])&&U(s[n],e[n])){const t=s[n];t.parentNode.replaceChild(e[n],t),t.children.length>0&&(n+=Y(t).length)}else"_events"in e[n]&&j(e[n],s[n])}e=[]}else!function(e,t){const n=e.getElementsByTagName("*").length,r=t.getElementsByTagName("*").length;return 0==n&&r>0||n>0&&0==r}(e,o)?U(e,o)?t.replaceChild(e,o):"_events"in e&&j(e,o):t.replaceChild(e,o)}function M(e,t){return!(e.nodeName==t.nodeName)}function U(e,t){let n=!1;const r=e.attributes,o=t.attributes;if(r.length!==o.length)n=!0;else for(let t of o){const r=t.name,o=t.value;if(!m(e,r)){n=!0;break}if(m(e,r)){if(x(e,r)!==o){n=!0;break}}}if(!n&&e.textContent&&t.textContent){if(W(e)&&W(t))return!1;n=e.textContent!==t.textContent}return n}function V(n,r,o){if(Se in n)return!1;const s=["push","unshift","pop","shift","splice","sort","fill","reverse"];for(let a of s)Object.defineProperty(n,[a],{value(){if(Array.prototype[a].call(this,...arguments),r(),"push"==a||"unshift"==a)for(let n of arguments)e(n)?q(n,r,o):t(n)&&V(n,r,o);else"splice"==a&&function(n,s,...a){if(l(a))for(let n of a)e(n)?q(n,r,o):t(n)&&V(n,r,o)}(...arguments)}});for(let s of n)e(s)?q(s,r,o):t(s)&&V(s,r,o);Object.defineProperty(n,Se,{value:!0,configurable:!1})}function q(n,r,s){if(Se in n)return!1;const a=Object.assign({},n),i=Object.keys(n);for(let o of i)s&&"defineProps"==o&&(n._defineProps=n[o],a._defineProps=n[o],delete n[o],delete a[o],p(`\n        "defineProps" is a reserved property in the objects which are the values\n        of data array in Inter.for(). So Inter redefined it to "${o="_defineProps"}".\n        \n        `)),Object.defineProperty(n,[o],{set(e){a[o]=e,r()},get:()=>a[o]}),e(n[o])?q(n[o],r,s):t(n[o])&&V(n[o],r,s);!s||"defineProps"in n||(Object.defineProperty(n,"defineProps",{set(t){e(t)||d(`\n            \n          The value of "defineProps" must be an object, and you defined\n          "${o(t)}" as its value.\n\n          Must be:\n\n          [The object].defineProps={\n\n            prop:value\n\n          }\n            \n\n            `);for(let[e,o]of Object.entries(t))e in this||(a[e]=o,Object.defineProperty(n,[e],{set(t){a[e]=t,r()},get:()=>a[e]}),r())}}),Object.defineProperty(n,Se,{value:!0,configurable:!1,writable:!1}))}function G(e){const t=oe.create(null),n=f(e).getElementsByTagName("*");for(let r=0;r<n.length;r++){const o=n[r].tagName,s=n[r];"input"!=de.call(o)&&"textarea"!=de.call(o)||t.push({input:s,index:r,parent:f(e)})}return t}function W(e){return e.children.length>0}function z(){this[Symbol()]=Object.create(null),this[Symbol()]=new Set}function F(e){return 1==e.nodeType}function Z(){}function J(t,n,o,a){Object.entries(n).reduce((e,n)=>{const[o,s]=n;void 0==s||"value"===o||"currentTime"===o||o.startsWith("on")?"value"==o||"currentTime"==o?t[o]=s:o.startsWith("on")&&r(s)&&(t[o]=function(e){s.call(a,e)}):b(t,o,s)},{}),Object.entries(a).reduce((e,n)=>{const[o]=n;Object.defineProperty(a,o,{set(e){void 0==e?o.startsWith("on")?t[o]=void 0:t.removeAttribute(o):o.startsWith("on")?(r(e)||d(`\n                        The value of "${e}" event, must be a function.\n                        `),t[o]=function(t){e.call(a,t)}):b(t,o,e)},get(){if(!o.startsWith("on"))return x(t,o);d(`\n               "${o}" seems to be an event listener, \n               and you can not get the value of an event.\n               `)}})},{});const i=Object.create(null);Object.defineProperty(i,[o],{value:new Proxy(n,{set(e,n,o,a){if(s.call(e,n)){if(void 0==o)return n.startsWith("on")?t[n]=void 0:t.removeAttribute(n),!1;"value"===n||"currenTime"===n||n.startsWith("on")?"value"==n||"currentTime"===n?(t[n]=o,Reflect.set(e,n,o,a)):n.startsWith("on")&&(r(o)||d(`\n                        Oh, the value of "${n}" event, must be a function.\n                        `),t[n]=function(t){o.call(e,t)}):(b(t,n,o),Reflect.set(e,n,o,a))}},get(e,n,r){if(!n.startsWith("on"))return t[n];d(`"${n}" seems to be an event listener, and you can\n            not get the value of an event`)}})}),e(ee.managers)||(ee.managers=Object.create(null)),ee.managers[o]=i[o]}function X(e,t){function n(){let t=-1;for(let e of r)if(t++,m(e,"_istrue")){m(e,"_default")&&d("\n            A container can not have two reactive attributes.\n            ");const n=x(e,"_istrue");e.istrue=!0;const r={ifTrue:e,cond:n.trim(),index:t},i=e.nextElementSibling;a(i)&&m(i,"_default")&&(m(i,"_istrue")&&d("\n                 A container can not have two reactives attributes.\n                 "),i.default=!0,r.default=i,i.removeAttribute("_default"),s.push(i)),e.removeAttribute("_istrue"),s.push(e),o.push(r)}for(let t of s)e.removeChild(t);je.hasListener("CONTAINERS_HAVE_FINISHED_LOADING")&&(je.fire("CONTAINERS_HAVE_FINISHED_LOADING"),je.removeListener("CONTAINERS_HAVE_FINISHED_LOADING"))}const r=e.children,o=oe.create(null),s=oe.create(null);if(O(t)){if("file:"==window.location.protocol)d('\n        You can not use container rendering with external template in\n        a "file:" protocol. Use "http:" or "https:" protocols instead.\n        ');else{const t=e.getElementsByTagName("inter-container"),r=t.length;let o=0;Ge.load(()=>{if(r>o){m(i=t[0],"path")||d('\n       \n       There is  an "inter-container" tag that does not have the "path" attribute.\n       \n       '),m(i,"tag")||d('\n   \n   There is an "inter-container" tag that does not have the "tag" attribute.\n\n   '),x(i,"path").endsWith(".html")||x(i,"path").endsWith(".hml")||d('\n    \n    The path attribute value in all "inter-container" tags must end either with the ".html"\n    or ".htm" extension.\n    \n    '),ve.request({type:"get",path:i.getAttribute("path")}).response(e=>{const t=i.attributes;/<style>(:?[\s\S])*<\/style>|<script>(:?[\s\S])*<\/script>/g.test(e)&&d(`\n        \n        In external template must not contain a <style> or <script> tag,\n        and one of the mentioned tag was found at path => "${i.getAttribute("path")}".\n        \n        `);const n=y(i.getAttribute("tag"));n.innerHTML=e;for(let e of t)"path"!=e.name&&"tag"!=e.name&&b(n,e.name,e.value);i.parentNode.replaceChild(n,i),Ge.call()},()=>{h(`\n       Failed to load: ${i.getAttribute("path")}.\n       `)}),o++}else n()}),Ge.fire()}}else n();var i;return o}function K(t,n){for(let s of n){e(s)||d(`\n                \n                The items of children array in template must be\n                only an object, and you defined it as "${o(s)}."\n                \n                `);let{tag:n,text:a,attrs:i={},events:c={},handlers:u={},styles:h={},children:f=[]}=s;if(void 0==(n=r(n)?n():n))continue;const m=y(n);m._events=Object.create(null),Object.entries(i).forEach(e=>{const[t,n]=e;l(n)&&(r(n)?b(m,t,n()):b(m,t,n))}),Object.entries(c).forEach(e=>{const[t,n]=e;t.startsWith("on")?r(n)&&T(t)?(m[t]=n,m._events[t]=n):T(t)||p(`\n                        \n                        "${t}" doesn't seem to be a valid dom's event.\n                        \n                        `):p(`\n                    \n                    Every HTML events must start with on. And\n        \n                    "${t}" does not.\n        \n        \n                    `)}),Object.entries(u).forEach(e=>{const[t,n]=e;r(n)?n.apply(m,void 0):d(`\n               \n               All handlers properties values must be functions,\n               and the value of "${t}"  handler is not.\n        \n               `)}),Object.entries(h).forEach(e=>{const[t,n]=e;l(n)&&!w(t)?p(`\n                \n                "${t}" doesn't seem to be a valid css style.\n                \n                `):l(n)&&(r(n)?m.style[t]=n():m.style[t]=n)}),l(a)&&0==f.length&&(r(a)?m.appendChild(g(a())):m.appendChild(g(a))),t.appendChild(m),f.length>0&&K(m,f)}}const Q={get status(){return ee.app.status}};Object.destroyAll=(e=>{const t=Object.keys(e);for(let n of t)delete e[n]}),Object.type=(t=>e(t)?"object":Array.isArray(t)?"array":void 0==t?"null":void 0),Object.defineProperty(Node.prototype,"getTextNodes",{get(){const e=new Set;if(this.hasChildNodes())for(let t of this.childNodes)3==t.nodeType&&i(t.textContent)&&e.add(t);return oe.create(e)}});const ee=globalThis||window,te=/^\/(:?[\s\S]+)|\/$/,ne=Symbol(),re={[ne]:Object.create(null),create(e){return this[ne][e]=oe.create(null)},set(e,t){this[ne][e].push(t)},get(e){return this[ne][e]},has(e){return e in this[ne]},reConstroy(e,t,n){let r=this.get(e);for(let e of r){const{text:r,target:o,refs:a}=e;s.call(a,t)&&(a[t]=n);let l=r,c=Object.getOwnPropertyNames(a);for(let e of c){const t=RegExp(`{(:?\\s+)*(:?${e})(:?\\s+)*}`,"g");if(!i(l=l.replace(t,a[e])))break}o.textContent=l}}};R.prototype={create:e=>null==e?[]:Array.from(e),shareItens(e,t){for(let n of e)t.push(n)},destroy(e){let t=e.length;for(;t--;)e.pop()}};var oe=new R;const se={handleMemory:new Set,addCont(e){this.handleMemory.add(e)},has(e){return this.handleMemory.has(e)}};let ae="development";const ie={get version(){return"1.2.13"},set status(e){if("production"!=ae&&"development"!=e){if("production"!=e)throw Error(`\n        "${e}" is an invalid value for the app.status property.\n     `);console.log("The app is now in production, every error will be\n        hidden.\n        "),ae=e}},get status(){return ae}};Object.preventExtensions(ie),Object.defineProperty(window,"onload",{set(e){this.addEventListener("load",t=>{"development"==ie.status&&console.log("You're using Inter in development mode, when you deploy your app turn on the production mode."),S(),r(e)&&e(t)})}}),window.onload=(()=>{S()});var le=new Proxy({url:function(e){return l(e)||d("The argument of validate.url() method must not be null or undefined."),/^(?:http:\/\/|https:\/\/)+(:?[A-Z]{2,8}\.)*(:?[a-z]+)+\.+(:?[a-z]{2,8})+(:?[\s\S])*$/i.test(e)},email:function(e){return l(e)||d("The argument of validate.email() method must not be null or undefined."),/^(?:[A-Z]+)+(:?[0-9]+)*@+(:?[A-Z]+)\.[A-Z]+$/i.test(e)}},{set:(e,t,n,r)=>"url"==t||"email"==t?(h("\n        You can not overwrite built-in methods\n        "),!1):Reflect.set(e,t,n,r),deleteProperty:(e,t)=>"url"==t||"email"==t?(h("\n                You can not delete built-in methods\n                "),!1):Reflect.deleteProperty(e,t)});const ce=new class{constructor(){}addHTML(n){if(e(n)){const{in:e,elements:o}=n;t(o)||d('\n        \n        "elements" must be an array in Inter.addHTML()\n        \n        ');const s=f(e);for(let e of o){const{tag:t,text:n,children:o=[],attrs:a={},events:i={}}=e;if(void 0==t)continue;let l=y(t);Object.entries(a).forEach(e=>{const[t,n]=e;b(l,t,n)}),Object.entries(i).forEach(e=>{const[t,n]=e;l[t]=n,s.appendChild(l)}),void 0!=n&&0==o.length&&(r(n)?void 0!=n()&&l.appendChild(g(n())):l.appendChild(g(n))),o.length>0&&K(l,o),s.appendChild(l)}}else d("\n         The argument passed in the method AddHTML must be a plain object.\n         ")}},ue=new Proxy(ce,{set:(...e)=>(d("You can not set any property in Inter object,\n        this is a fatal action.\n        "),!1),deleteProperty:(...e)=>(d("Fatal error: do not try to delete any property of Inter object"),!1),getPrototypeOf:e=>null,setPrototypeOf:(...e)=>!1}),de=String.prototype.toLowerCase;Object.defineProperties(ce,{[Symbol.hasInstance]:{get:()=>!1},[Symbol.toStringTag]:{get:()=>"Inter"}});const he=new function(){this.query=function(n){if(e(n)){const{in:r,setting:o}=n,{applyTo:a,value:i,query:l}=o;e(o)||d("\n       Setting must be an object.\n       "),t(r)&&t(a)||d("\n        The in=>target and the applyTo=>reciever properties must be array.\n        ");let c=r.filter(e=>{s.call(e,l)||console.log(`It's was not found a property called "${l}" in target object, in data.query()`);const t=e[l];if(de.call(t).includes(de.call(i)))return e});if(oe.destroy(a),""===i)return!1;oe.shareItens(c,a)}else d("\nThe argument of data.query() must be an object.\n")}};Object.defineProperty(he,"query",{enumerable:!0,value:he.query}),Object.freeze(he);const fe={refHandler:Object.create(null),has:function(e){return e in this.refHandler},get:function(e){return this.refHandler[e]},addRef:function(e,t){return this.refHandler[e]=t},freeAll(){return Object.destroyAll(this.refHandler)}};L(ue,"renderIf",r=>{const o=oe.create(null);if(e(r)){const{in:i,watch:c,conditions:u}=r;function a(){const e=f(i);o.length>0&&(o.forEach((t,n)=>{const{el:r,index:o}=t;e.removeChild(r)}),oe.destroy(o)),t(u)||d("\n        conditions must be an array.\n        "),[...u].forEach((t,r)=>{const{render:a}=t;if(!l(a.call(t))&&s.call(o,t.index+"")){const n=e.children[t.index];e.removeChild(n),delete o[t.index+""]}if(A(a.call(t))){const r=t.index,s=e.children[r];if(n(r)){let n=e.children[r];if(1==e.children.length&&!l(t.replace)&&0==r){const t=e.children[0];return e.insertBefore(a()[0],t),o.push({el:e.children[r],index:r}),!1}if(l(s)&&O(t.replace))return e.replaceChild(a()[0],s),o.push({el:e.children[r],index:r}),!1;if(l(n))e.insertBefore(a()[0],n),o.push({el:e.children[r],index:r});else{e.children.length-1+1==r?(e.appendChild(a()[0]),o.push({el:e.children[r],index:r})):d(`Invalid index, it's impossible to render the element at index "${r}"!\n                         `)}}else d("\n                 The index in Inter.renderIf() must be a number.\n                 ")}})}e(c)||d("You must define the watch proprety and it's value must be an object."),q(c,a)}else d("\n        \n        The argument of Inter.renderIf() method must be\n        an object.\n\n        ");a()});const pe=new class{constructor(){}typing(t){if(e(t)){const{in:e,setting:o,done:s}=t;var n=f(e);Array.from(o).forEach(e=>{const{text:t,speed:o}=e;let a=[...t][Symbol.iterator](),i=setInterval(()=>{let e=a.next().value;if(void 0!==e)fe.has(n)?(n.textContent=`${fe.get(n)}${e}`,fe.addRef(n,`${fe.get(n)}${e}`)):(n.textContent=e,fe.addRef(n,e));else if(clearInterval(i),r(s))return s()},+o)})}else d("\n        \n        The argument of simulate.typing(arg:Object) must be a plain object.\n        \n        ")}cleaning(t){if(e(t)){const{in:e,speed:n,done:o}=t,s=f(e),a=[...s.textContent];let i=setInterval(()=>{a.pop(),s.textContent=function(e){let t=[...e];return t.pop(),t.reduce((e,t)=>e.concat(t),"")}(s.textContent),l(a[0])||(clearInterval(i),fe.has(s)&&delete fe.refHandler[s],r(o)&&o())},+n)}else d("\n       The value passed as the argument in the method cleaning must be an object.\n       ")}};var ge=new Proxy(pe,{deleteProperty:(...e)=>(d("\n        You can not delety any property in\n        simulate object\n        \n        "),!1),defineProperty:(...e)=>!1,set:(...e)=>!0,getPrototypeOf:e=>null,setPrototypeOf:(e,t)=>!1});P.prototype.useHash=(e=>{te.test(e)||d("\n        pathName must starts with /.\n        ");const t=window.location.pathname;return l(e)||d("You must define the path of the url."),"/"==e?(window.history.pushState(null,null,`/#${e}`),je.fire("URLCHANGED"),!1):"/"!=e&&"/"==t?(window.history.pushState(null,null,`/#${e}`),je.fire("URLCHANGED"),!1):(window.history.replaceState(null,null,`/#${e}`),void je.fire("URLCHANGED"))}),P.prototype.setPath=(e=>{const t=window.location.pathname;return te.test(e)||d("\n     Pathname must starts with /.\n     "),l(e)||d("\n    setPath's parameter must not be a null or undefined value.\n    "),"/"==e?(window.history.pushState(null,null,e),je.fire("URLCHANGED"),!1):"/"!=e&&"/"==t?(window.history.pushState(null,null,e),je.fire("URLCHANGED"),!1):(window.history.replaceState(null,null,e),void je.fire("URLCHANGED"))});const me=Object.freeze(new P),ye={handler:Object.create(null),justRegistered(e){return e in this.handler}},be=String.prototype.toUpperCase;I.prototype.request=function(t){function s(){l(y)&&(n(y)?j.timeout=y:p(`\n                \n    \n                The timeout property's value must be a number,\n                and you defined ${o(y)} as its value.\n    \n                `)),O(b)&&(j.withCredentials=!0);const t=be.call(i);H(m)||!l(m)?j.open(t,c,!0):e(m)&&m.username&&m.password&&j.open(t,c,!0,m.username,m.password),Object.entries(f).forEach(e=>{const[t,n]=e;j.setRequestHeader(t,n)}),Object.entries(u).forEach(e=>{const[t,n]=e;de.call(t)in x||h(`\n            \n            "${t}" is an unrecognised backend.request() event.\n            `),r(n)&&de.call(t)in x&&(j[t]=function(e){if("onprogress"==t){const t=Math.round(100*e.loaded/e.total);n(t)}else n()})}),j.onload=function(){let e=null;try{if(e=JSON.parse(this.responseText),200!==this.status)return r(a.error)&&a.error.call(v,e),!1;r(a.okay)&&a.okay.call(v,e)}catch(t){if(e=this.responseText,200!==this.status)return r(a.error)&&a.error.call(v,e),!1;r(a.okay)&&a.okay.call(v,e)}},j.onerror=function(){r(a.error)&&a.error.call(v,this.statusText)},"GET"==t?j.send(null):l(g)&&j.send(g)}"file:"==window.location.protocol&&h('\n    \n    You can not use the backend.request() method\n    in an "file:" protocol, use a "http:" or "https:" protocol instead.\n\n    ');const a={_set(e,t){this[e]=t},okay:null,error:null};e(t)||d(`\n       \n       The argument of backend.request()\n       must be an object and not: ${o(t)}\n\n       \n       `);const{type:i,path:c,events:u={},headers:f={},body:g,security:m={},timeout:y,withCridentials:b}=t,v={get[Symbol.toStringTag](){return"Ajaxresponse"},get status(){return j.status},get statusText(){return j.statusText},isObj(){try{return JSON.parse(j.responseText),!0}catch(e){return!1}},get headers(){return j.getAllResponseHeaders()}},x={ontimeout:!0,onabort:!0,onprogress:!0};let j=new XMLHttpRequest;return{okay(e){r(e)?(a._set("okay",e),s()):d("\n         The argument of okay response method must be a function.\n         ")},error(e){r(e)?(a._set("error",e),s()):d("\n         The argument of error response method must be a function.\n         ")},response(e,t){2>arguments.length&&d("\n           backend.request().response() must have two arguments.\n           "),r(e)&&r(t)?(a._set("okay",e),a._set("error",t),s()):d("\n         The arguments of backend.request().response() must be functions.\n         ")}}};const ve=Object.freeze(new I),xe={protectedListener:Object.create(null),ref:Object.create(null),add:function(e,t){this.ref[e]=t}},Oe=new Proxy({},{set(e,t,n,r){t in xe.ref&&xe.ref[t](n)}}),je=Object.freeze(new function(){this.fire=((e,t)=>(l(e)||d("\n             You must define the event's name.\n             "),l(t)?!!this.hasListener(e)&&(Oe[e]=t,!0):!!this.hasListener(e)&&(Oe[e]=void 0,!0))),this.listen=((e,t)=>(void 0==e&&d("The first argument of event.listen() must be defined(the event's name)."),r(t)||d("\n             The second argument of event.listen() must be a function.\n             "),!s.call(xe.ref,e)&&(xe.add(e,t),!0))),this.removeListener=(e=>{if(l(e)){if(!s.call(xe.ref,e))return p(`\n    Ops, you are trying to delete a listener that  does not exist!\n    Listener: [${e}].\n    `),!1;if(!s.call(xe.protectedListener,e))return delete xe.ref[e];d(`\n    The listener of "${e}" is protected, you can not remove it.\n    `)}else d("\n    You must define the event's name that you want to remove its listener.\n    ")}),this.protectListener=(e=>s.call(xe.protectedListener,e)?(p(`The listener of "${e}" is already protected. `),!1):(xe.protectedListener[e]=!0,!0)),this.hasListener=(e=>!!s.call(xe.ref,e))}),we=new Proxy(Object.create(null),{set:(e,t,n,r)=>t in we?"Inter here":Reflect.set(e,t,n,r)}),Te={handler:{},get(e){return this.handler[e]},has(e){return e in this.handler},add(e,t){return this.handler[e].push(t)},create(e){if(e in this.handler)return!1;this.handler[e]=oe.create(null)}};k.prototype.each=((e,t,n,r)=>{if(_(e)){const n=e.childNodes;for(let e=0;e<n.length;e++)if("[object Text]"==n[e]){RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(n[e].textContent)&&Ee.push({text:n[e].textContent,target:n[e]})}}else{RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(e.textContent)&&Ee.push({target:e,text:e.textContent})}r&&$e.set(n,Ee)});const Ee=oe.create(null);let Ce=new k;const Ne={handle:Object.create(null),set(e,t){return this.handle[e]=t},get(e){return this.handle[e]},has(e){return e in this.handle}},Re={handler:Object.create(null),set(e){this.handler[e]=!0},has(e){return e in this.handler},delete(e){delete this.handler[e]}};let Ae={storage:Object.create(null),set(e,t){return this.storage[e]=t},get(e){return this.storage[e]}},$e={storage:Object.create(null),set(e,t){this.storage[e]=t},get(e){return this.storage[e]},has(e){return e in this.storage}};const Pe={store:new Set,add(e){this.store.has(e)||this.store.add(e)},has(e){return this.store.has(e)}},Se=Symbol();L(ue,"for",n=>{let{in:o,do:s,data:a,react:i}=n,c=null;const u=new Set;if(t(a)){!function n(){c=new Proxy(a,{set:(n,r,o,s)=>(n[r]=o,e(o)?q(o,g,!0):t(o)&&V(o,g,!0),g(),!0)}),Object.defineProperty(c,"otherArray",{set(r){if(t(r)){a=r,g();for(let n of r)e(n)?q(n,g,!0):t(n)&&V(n,g,!0);n()}else d(`\n         "${r}" is not an array.\n         `)},get:()=>null,configurable:!0}),Object.defineProperty(c,"addValues",{value(n,r){if(t(n)||d("\n            \n            The first argument of [ ARRAY REACTOR ].addValues()\n            must be an array.\n            \n            "),$(n))return p("\n            \n            The first argument of [ ARRAY REACTOR ].addValues()\n            is an empty array.\n\n            "),!1;if(!l(r)||r>a.length-1){for(let r of n)e(r)?q(r,g,!0):t(r)&&V(r,g,!0),a.push(r);g()}else if(0==r||0>r){for(let r=n.length-1;r>-1;r--)e(n[r])?q(n[r],g,!0):t(n[r])&&V(n[r],g,!0),a.unshift(n[r]);g()}else{for(let o of n)e(o)?q(o,g,!0):t(o)&&V(o,g,!0),a.splice(r,0,o);g()}},configurable:!0}),Object.defineProperty(c,"concat",{value:n=>{if(t(n)){for(let e of n)c.push(e);return oe.create(a)}return c.push(n),e(n)?q(n,g,!0):t(n)&&V(n,g,!0),oe.create(a)},configurable:!0}),l(i)&&(window[i]=c)}()}if(t(a)||h("data in Inter.for() must be an array."),r(s)){const n=f(o);for(let n of a)e(n)?q(n,g,!0):t(n)&&V(n,g,!0);function g(){if(a.length<n.children.length){let e=n.children;for(let t=e.length;t>a.length;--t)n.removeChild(e[e.length-1])}if(!Pe.has(o))return a.forEach((e,t)=>{var r=s.call(c,e,t);A(r)||d(`\n                You are not returning the template()\n                function in do() method(Inter.for). It is happening where the target id is "${o}".\n\t\t\t\t\n\n                `);for(let e of r)n.appendChild(e)}),Pe.add(o),!1;Pe.has(o)&&a.forEach((e,t)=>{let r=s.call(c,e,t);if(A(r)){if(l(n.children[t]))for(let o of r)B(o,n,t,()=>s.call(c,e,t));else if(!l(n.children[t])&&a.length-u.size>n.children.length)for(v of r)return void n.appendChild(v)}else d(`\n                You are not returning the template()\n                function in do() method(Inter.for). It is happening where the target id is "${o}".\n\t\t\t\t\n\n                `)})}}else h("do in Inter.for() must be a function");g()});const Ie={store:Object.create(null),set(e,t){this.store[e]=t},hasNotFound(){return"*"in this.store},get(){return this.store["*"]()}};let Le=!1;let He=new class{constructor(){}each(e){const{in:t,do:n}=e;let r=oe.create(null),o=f(t).getElementsByTagName("*");for(let e of o)u(e)&&r.push(e);for(let e=0;e<r.length;e++)n(r[e],e)}};const ke=Symbol.for("privateMethod"),_e=oe.create(null),Ye=Symbol(),De=Symbol(),Be=Symbol(),Me=oe.create(null),Ue={[Ye]:void 0,[ke]:Object.create(null),[De]:!0,[Be]:oe.create(null),setState(e,t){if(e in this[ke]&&p(`\n      Oh no! The state that you're registering already exist "${e}".\n      \n      `),2>arguments.length)d("\n        input.sateSate() must have two arguments, first is the name of the state \n        and second the input state container.\n        ");else{const n=G(t);for(let e=0;e<n.length;e++){const{input:t,index:r,parent:o}=n[e],s=t.cloneNode(!0);_e.push({clonedInput:s,index:r,parent:o}),this[De]&&Me.push({realInput:t,index:r,parent:o})}this[ke][e]=oe.create(null),oe.shareItens(_e,this[ke][e]),oe.destroy(_e),this[De]&&(oe.shareItens(Me,this[Be]),oe.destroy(Me),this[De]=!1)}},original(){const e=this[Be];for(let t of e){const{realInput:e,index:n,parent:r}=t,o=r.getElementsByTagName("*");r.replaceChild(e,o[n])}},resetState(e,t){if(!e in this[ke]&&p("The state you'e trying to reset does not exist."),2>arguments.length)d("resetState must have two arguments.");else{const n=G(t);for(let e=0;e<n.length;e++){const{input:t,index:r,parent:o}=n[e],s=t.cloneNode(!0);_e.push({clonedInput:s,index:r,parent:o})}this[ke][e]=oe.create(null),oe.shareItens(_e,this[ke][e]),oe.destroy(_e)}},deleteState(e){if(!(!e in this[ke]))return delete this[ke][e];p("\n        You're trying to delete a state that does not exist.\n        ")},constroyState(e){if(!e in this[ke])p("\n        You're trying to constroy a state that does not exist.\n        ");else{const t=this[ke][e];for(let e of t){const{clonedInput:t,index:n,parent:r}=e,o=r.getElementsByTagName("*");r.replaceChild(t,o[n])}}},destroyAll(){for(let e in this[ke])return delete this[ke][e]},send(e){if(r(e)){Object.getOwnPropertyNames(this[ke]).forEach(t=>{const n=this[ke][t];for(let t of n)e(t.clonedInput)})}else d("\n    send's argument must be a function.\n    ")}};Object.freeze(Ue),z.prototype.set=function(e,t){const n=Object.getOwnPropertySymbols(this)[0];if(2>arguments.length&&d("\n        storage.set() must have two arguments!\n        "),this[Object.getOwnPropertySymbols(this)[1]].has(e)&&d(`\n       \n       The info named "${e}" is protect\n       and you can not overwritten it.\n\n       `),!(e in this[n]))return this[n][e]=t;this[n][e]=t,p(`\n        there's already an element named "${e}" on the storage, and it's value\n        was overwritten.\n        `)},z.prototype.get=function(e,t){const n=Object.getOwnPropertySymbols(this)[0];if(2>arguments.length&&d("\n    storage.get() must have two arguments!\n    "),r(t)||d("\n    The second argument in storage.get() must be a function.\n    "),s.call(this[n],e)){return t(this[n][e])}p("\n    You are trying to get an element that is not actually registered in the storage.\n    ")},z.prototype.has=function(e){const t=Object.getOwnPropertySymbols(this)[0];if(l(e))return s.call(this[t],e);d("\n        You must define the element to check its existence in the storage.\n        ")},z.prototype.delete=function(e){const t=Object.getOwnPropertySymbols(this)[0];if(l(e)||d("You must define the key you want to delete from storage."),s.call(this[t],e)){this[Object.getOwnPropertySymbols(this)[1]].has(e)&&d(`\n            \n            The info named "${e}" is protect\n            and you can not delete it from the storage.\n\n            `),delete this[t][key]}else d("\n         You're trying to delete a key that is not in the storage.\n         ")},z.prototype.protect=function(e){if(void 0==e&&d("\n        \n        You must define the info name to protect\n        in storage.protect(infoName)\n\n        "),this.has(e)){this[Object.getOwnPropertySymbols(this)[1]].add(e)}else d(`\n        \n        The info named ${e} is not on the storage yet,\n        so register it first and then protect it.\n        \n        `)};const Ve=Object.freeze(new z);Z.prototype.previous=((e,t)=>{if(F(e),r(t)){const n=oe.create(null),r=e.parentNode.children;for(child of r){if(e.isSameNode(child)){n.push(child),t([...n]),oe.destroy(n);break}n.push(child)}}else;}),Z.prototype.next=((e,t)=>{if(F(e)||d('\nThe first argument in "interface.next()" must be a valid HTML element.\n'),r(t)){let n=!1
;const r=oe.create(null),o=e.parentNode.children;for(let t of o)(e.isSameNode(t)||n)&&(r.push(t),n||(n=!0));t([...r]),oe.destroy(r)}else d('\nThe second argument in "interface.next()" must be a function.\n')});const qe=Object.freeze(new Z);je.protectListener("URLCHANGED"),je.protectListener("handler");const Ge={call:void 0,load(e){this.call=e},fire(){this.call()}};ee.renderContainer=function(n){let a=void 0;if(void 0!==new.target&&d('\n        "renderContainer" is not a constructor, do not call it\n        with the "new" keyword.\n        '),e(n)){const{in:u,data:h,react:g,private:m,load:y,loadState:b}=n;e(h)||d("\n    \n    The data property in renderContainer argument must be an object.\n\n    "),r(b)&&y&&b.call(h,"loading");const v=X(f(u),O(y)),x=Object.assign({},h),j=Object.assign({},h),w=Object.getOwnPropertyNames(h);for(let e of w)"register"!=e&&"setRegistered"!=e||d(`\n        \n        "${e}" is a reserved property, you can not\n        use it as rendering property.\n\n        renderContainer({\n            in:"${u}",\n            data:{\n                ${e}:${h[e]}\n            }\n            ...\n        })\n\n        `),Object.defineProperty(x,[e],{set(t){j[e]=t,i()},get:()=>j[e]});const T=oe.create(null);let E=!1;function i(){for(let e of v){const{cond:t,ifTrue:n,default:a,index:i}=e,d=f(u),h=d.children;if("setRegistered"!=t&&"register"!=t&&s.call(x,t)){const e=r(x[t])?x[t].apply(x,void 0):x[t];if(c(e)||p(`\n            The values of properties in data object, in renderContainer(), must be\n            only boolean(true/false), and in property "${t}" you defined\n            "${o(e)}" as its value.\n                `),!N(e,!0)&&l(a)){if(a.parentNode==d){d.replaceChild(n,a);continue}if(void 0==h[i]){d.appendChild(n);continue}if(h[i].isSameNode(n))continue;d.insertBefore(n,h[i])}else{if(!N(e,!1)&&l(a)){if(n.parentNode==d){d.replaceChild(a,n);continue}if(void 0==h[i]){d.appendChild(a);continue}if(h[i].isSameNode(a))continue}if(!N(e,!0)&&!l(a)){if(void 0==h[i]){d.appendChild(n);continue}h[i].isSameNode(n)||d.insertBefore(n,h[i])}}N(e,!1)||l(a)||n.parentNode==d&&d.removeChild(n)}}}Object.defineProperty(x,"register",{set(e){if(t(e)||d("\n            The value in [ CONTAINER RENDERING REACTOR ].register must be an array.\n            "),E)return p("\n            You can only register the properties once.\n            "),!1;if($(e))d("\n            The value of register property must not be an empty array.\n            ");else{for(let t of e)"register"!=t&&"setRegistered"!=t&&(s.call(h,t)?(T.push(t),E=!0):p(`\n                    There is not a rendering property named "${t}"\n                    in container rendering in the element whose the id attribute is "${u}"\n                    `));Object.defineProperty(this,"setRegistered",{enumerable:!1,configurable:!1,set(e){if(c(e)){for(let t of T)j[t]=e;i()}else d("\n                        The setRegistered property only accepts\n                        boolean value, true or false.\n                        ")}}),Object.seal(this)}}}),y&&je.listen("CONTAINERS_HAVE_FINISHED_LOADING",()=>{i(),r(b)&&y&&b.call(x,"ready")}),y||i(),l(g)?ee[g]=x:m&&(a=x)}else d('\n        The argument in "renderContainer" must be an object.\n        ');return a},ee.interface=qe,ee.storage=Ve,ee.input=Ue,ee.form=He,ee.toHTML=function(t){let n;if(e(t)){const{in:a,data:i,handleValue:c,private:u,react:p}=t;if(se.has(a))return h(`\n        \n        You've already registered the references\n        in the container where the id is "${a}"\n        \n        `),!1;"setRefs"in i&&d('\n        \n        "setRefs" is a reserved property, you can not use it \n        as a reference\'s name.\n        \n        ');const g=Object.assign(Object.create(null),i),m=Object.assign(Object.create(null),i);Object.getOwnPropertyNames(i).forEach(e=>{r(i[e])&&(g[e]=i[e].call(i))}),se.addCont(a);const y=f(a).getElementsByTagName("*"),v=0!=y.length;je.listen(`handler${a}`,()=>{const t=Object.create(null);e(c)&&(Object.entries(c).forEach(e=>{const[n,r]=e;t[n]=r}),Object.entries(c).forEach((e,n)=>{const[r,o]=e;let s=ye.handler[a];for(let e of s){const{target:n,text:s,input:a}=e,i=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g");if(i.test(s)){const e=s.replace(i,o);n.textContent=e}let l=new Proxy(t,{get:()=>a.value,set(e,t,o,a){const i=RegExp(`{(:?\\s+)*(:?${r})(:?\\s+)*}`,"g"),l=s.replace(i,o);n.textContent=l}});window[r]=l}}))});const O=f(a).getElementsByTagName("*");var s=Object.keys(g);if(f(a).getTextNodes.length>0){Te.create(a);for(let e of f(a).getTextNodes)for(let t of Object.keys(i))RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(e.textContent)&&Te.add(a,{target:e,text:e.textContent})}for(let e=0;e<O.length;e++){Te.has(a)||Te.create(a);for(let t of s){const n=O[e];if(_(n)){const e=n.childNodes;for(let n of e)RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(n.textContent)&&Te.add(a,{target:n,text:n.textContent})}else RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(O[e].textContent)&&Te.add(a,{target:O[e],text:O[e].textContent,attrName:null});const r=O[e].getAttributeNames();for(let n=0;n<r.length;n++)if(v){const o=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g"),s=x(O[e],r[n]);o.test(s)&&Te.add(a,{target:O[e],attrName:r[n],attrValue:O[e].getAttribute(r[n])})}}}if(!H(i)){const t=Object.create(null);Object.defineProperty(t,"reactor",{value:new Proxy(m,{set(e,t,n,r){if(t in e)g[t]="function"==typeof n?n.call(r):n,n=g[t],Reflect.set(e,t,n,r),Te.handler[a].forEach((e,r)=>{const{text:o,target:s,attrName:i,attrValue:c}=e,u=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g");if(l(o))u.test(o)&&re.has(a)&&re.reConstroy(a,t,n);else if(u.test(c)){const e=c.replace(u,n);e==c||("value"!=i?b(s,i,e):s.value=e)}});else{const o={refName:t,refValue:n,refContainer:a};Reflect.set(e,t,n,r),function(e){const{refName:t,refValue:n,refContainer:r}=e,o=f(r).getElementsByTagName("*"),s=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g");for(let e of o)if(W(e)){const o=e.childNodes;for(let e of o)if(s.test(e.textContent)){Te.add(r,{target:e,text:e.textContent});const o=e.textContent.replace(s,n);re.set(r,{target:e,text:e.textContent,refs:{[t]:n}}),e.textContent=o}}else if(s.test(e.textContent)){Te.add(r,{target:e,text:e.textContent});const o=e.textContent.replace(s,n);re.set(r,{target:e,text:e.textContent,refs:{[t]:n}}),e.textContent=o}for(let e of o){const t=e.attributes;for(let o=0;o<t.length;o++)if(s.test(t[o].value)){Te.add(r,{target:e,attrName:t[o].name,attrValue:t[o].value});const a=t[o].value.replace(s,n);"value"!=t[o].name?b(e,t[o].name,a):e.value=a}}}(o),Re.set(t)}},get:(e,t,n)=>Ne.has(t)?Ne.get(t).value:g[t],deleteProperty(e,t,n){Re.has(t)&&(Reflect.deleteProperty(e,t,n),Re.delete(t),Te.handler[a].forEach((e,n)=>{const{target:r,text:o,attrName:s,attrValue:i}=e,c=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g");l(s)&&c.test(i)&&Te.handler[a].splice(n,1),l(o)&&c.test(o)&&Te.handler[a].splice(n,1)}))}}),enumerable:!0,configurable:!0,writable:!0}),Object.defineProperty(t.reactor,"setRefs",{set(t){e(t)||d(`\n                \n                The value of [ REFERENCE REACTOR ].setRefs must be an object\n                and you defined "${o(t)}" as its value.\n\n                `);for(let[e,n]of Object.entries(t))this[e]=n},configurable:!1}),0!=u&&l(u)?n=t.reactor:l(p)&&(ee[p]=t.reactor)}if(!H(i)&&l(i)){if(!$e.has(a)){const e=f(a).getElementsByTagName("*");y.length,oe.create(null);let t=oe.create(null);if(f(a).getTextNodes.length>0){for(let e of f(a).getTextNodes)for(let t of Object.keys(i))RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g").test(e.textContent)&&Ee.push({target:e,text:e.textContent});0==f(a).children.length&&$e.set(a,Ee)}for(let n=0;n<e.length;n++){const r=Object.getOwnPropertyNames(i);for(let o=0;o<r.length;o++){const s=n==e.length-1;Ce.each(e[n],r[o],a,s);const i=e[n].getAttributeNames();for(let s=0;s<i.length;s++){const a=x(e[n],i[s]);if(RegExp(`{(:?\\s+)*(:?${r[o]})(:?\\s+)*}`,"g").test(a)){const r=x(e[n],i[s]),o=i[s];t.push({target:e[n],attrName:o,attrText:r})}}}}Ae.set(a,t)}Object.entries(g).forEach(e=>{let[t,n]=e;const r=$e.get(a),o=Ae.get(a);re.create(a);let s=re.get(a);oe.shareItens(r,s);for(let e=0;e<r.length;e++){const{target:o,text:a}=r[e],{computed:i}=s[e];if(l(i)){const r=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g"),a=i.replace(r,n);s[e].computed=a,s[e].refs[t]=n,o.textContent=a}else{const r=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g");let i=a.replace(r,n);s[e].computed=i,s[e].refs=Object.create(null),s[e].refs[t]=n,o.textContent=i}}for(let e=0;e<o.length;e++){const{target:r,attrName:s,attrText:a}=o[e],i=RegExp(`{(:?\\s+)*(:?${t})(:?\\s+)*}`,"g");i.test(a)&&(b(r,s,a.replace(i,n)),"value"==s&&Ne.set(t,r))}})}}else d("The argument of toHTML() function must be an object.");return n},ee.validate=le,ee.Inter=ue,ee.simulate=ge,ee.ROUTER=function t(n){if(Le)return p("\n        \n        You already created the ROUTER.\n\n        "),!1;if(this instanceof t&&d("\n        \n        ROUTER is not an constructor. Just call it like that:\n\n        ROUTER({\n\n            routes:{\n\n                // your app's routes here!\n\n            }\n\n        })\n\n        "),"file:"==window.location.protocol&&d("\n        \n        The ROUTER must be only used in a http: or https:\n        protocol, and you are using it an file: protocol!\n        \n        "),e(n)){const{routes:e}=n,t=Object.create(null);Object.entries(e).forEach(e=>{const[n,o]=e;if(te.test(n)||"*"==n||d("\n        Route name must start with /.\n        "),r(o)||d("\n        Route action/handler must be a function.\n        "),"*"!=n&&n.includes("*")){let e=n.replaceAll("?","(:?\\?)");e=e.replaceAll("*","(:?[\\s\\S]+)"),t[e]=o}else"*"!==n&&(t[n]=o)}),r(e["*"])&&Ie.set("*",e["*"]),Le=!0,je.listen("URLCHANGED",()=>{const e=ee.location.search,n=e;if(e&&Object.keys(t).some(e=>{let r=/(?:)/,o=e.replace(/\//,"");r.compile(o).test(n)&&(t[e](),done=!0,C.call(document.body))}),window.location.hash){const e=window.decodeURI(window.location.hash.replace("#",""));Object.keys(t).some(n=>{/(?:)/.compile(n).test(e)&&(t[n](),done=!0,C.call(document.body))}),done||(Ie.hasNotFound()?Ie.get():p('\n             You should always create a notfound route with "*" property.\n             '))}else{const e=window.location.pathname;let n=!1;Object.keys(t).some(r=>{/(?:)/.compile(r).test(e)&&(t[r](),n=!0,C.call(document.body))})}}),je.fire("URLCHANGED"),window.onpopstate=(()=>{je.fire("URLCHANGED")})}else d("\nThe argument of ROUTER() must be an object.\n");C.call(document.body)},ee.supportInter=function(){void 0!=new.target&&d('\n        \n        Do not call the "supportInter()" function with the "new" keyword,\n        just invoke it like that: supportInter()\n        \n        ');try{let e=new Map;return e.set("framework","Inter"),e.set("Creator","Denis"),e.clear(),!0}catch(e){return!1}},ee.url=me,ee.data=he,ee.backend=ve,ee.event=je,ee.whileLoading=function(t){if(void 0!==new.target&&d("\n       You must not create an instance for whileLoading() function, call it\n       whileLoading(argument(object)). \n       "),e(t)){const{elements:e}=t;let n=null;[...e].forEach(e=>{const{tag:t,text:o,attrs:s={},events:a={},children:i=[],styles:c={}}=e,u=y(t);Object.entries(s).forEach(e=>{const[t,n]=e;b(u,t,n)}),Object.entries(a).forEach(e=>{const[t,n]=e;u[t]=n}),Object.entries(c).forEach(e=>{const[t,n]=e;r(n)?u.style[t]=n():u.style[t]=n}),l(o)&&0==i.length&&(r(o)?u.appendChild(g(o)):u.appendChild(TExt(o))),i.length>0&&K(u,i),n=u,document.body.appendChild(u)}),document.onreadystatechange=function(){"complete"==this.readyState&&this.body.removeChild(n)}}else d("\n         The argument of whileLoading() function must be an object.\n       \n       ")},ee.app=ie,ee.template=function(t){void 0!==new.target&&d("\n            \n            The template function is not a constructor,\n            do not call it with the new keyword.\n            \n            "),e(t)||d(`\n            \n            The argument of the template function must be\n            a plain object, but you defined ${o(t)} as\n            its argument.\n            \n            `);const{elements:n}=t;Array.isArray(n)||d("\n    \n    elements in template must be an array of object.\n    \n    "),n.length>1&&p('\n    \n    You are creating more than one element without a container in template function, \n    put the created elements inside a container like:\n\n    template({\n        elements:[{\n            //container.\n            tag:"div", children:[{\n\n                //The elements here!\n\n            }]\n        }]\n    })\n    \n    ');let s=oe.create(null);e(n[0])||d(`\n    \n    The items of the elements array in template,\n    must be only objects, but you defined "${o(n[0])}"\n    as the first value of the elements array.\n    \n    `);let{tag:a,text:i,attrs:c={},events:u={},handlers:h={},styles:f={},children:m=[]}=n[0];void 0==(a=r(a)?a():a)&&d("\n        \n        You can not render a container conditionally, in template function.\n        \n        ");const v=y(a);return v._events=Object.create(null),Object.entries(c).forEach(e=>{const[t,n]=e;l(t)&&(r(n)?b(v,t,n()):b(v,t,n))}),Object.entries(u).forEach(e=>{const[t,n]=e;t.startsWith("on")?r(n)&&T(t)?(v[t]=n,v._events[t]=n):T(t)||p(`\n            \n            "${t}" doesn't seem to be a valid\n            dom's event.\n            \n            `):p(`\n            \n            Every HTML events must start with "on". And\n\n            "${t}" does not.\n\n\n            `)}),Object.entries(h).forEach(e=>{const[t,n]=e;r(n)?(n.apply(v,void 0),n.render=!0):d(`\n       \n       All handlers properties values must be functions,\n       and the value of handler "${t}" is not.\n\n       `)}),Object.entries(f).forEach(e=>{const[t,n]=e;l(t)&&!w(t)?p(`\n            \n            "${t}" doesn't seem to be a valid css style.\n            \n            `):l(n)&&(r(n)?v.style[t]=n():v.style[t]=n)}),l(i)&&0==m.length&&(r(i),v.appendChild(g(i))),m.length>0&&K(v,m),s.push(v),s},ee.toATTR=function(t){const n=Object.create(null);if(e(t)){const{in:r,data:o,private:s}=t;"string"!=typeof r&&syntaxErr('\n    \n    The "in" property in toATTR() function\n    must be defined and must be a type of string.\n    \n    ');const a=f(r);if(e(o)){!function(e,t){const n=Object.getOwnPropertyNames(t),r=e.getElementsByTagName("*");for(let e of r)if(1==e.attributes.length){const r=e.attributes[0].name;for(let o of n)if(RegExp(`{...${o}}`).test(r)){const n=Object.assign({},t[o]);e.removeAttribute(r),J(e,n,o,t[o]);break}}}(a,o);for(let e of Object.entries(ee.managers)){const[t,r]=e;O(s)?n[t]=r:ee[t]=r}}else d("\ndata in toATTR() must be an object.\n");return delete ee.managers,O(s)?n:void 0}d('\n        The argument of "toATTR()" function must be an object.\n        ')}}();