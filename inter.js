(function () {
  /**
   * Interjs
   * Version - 2.0.13
   * MIT LICENSED BY - Denis Power
   * Repo - https://github.com/interjs/inter
   * 2021-2022
   * GENERATED BY INTER BUILDER
   *
   *
   */

  // Helpers functions.

  function isValidTemplateReturn(arg) {
    return isObj(arg) && arg.element && arg[Symbol.for("template")];
  }

  function isNotConfigurable(obj) {
    return (
      Object.isFrozen(obj) || Object.isSealed(obj) || !Object.isExtensible(obj)
    );
  }

  function isObj(o) {
    // For plain objects.

    return Object.prototype.toString.apply(o, void 0) == "[object Object]";
  }

  function isSet(o) {
    return o instanceof Set;
  }

  function isMap(o) {
    return o instanceof Map;
  }

  function isDefined(t) {
    return t != void 0;
  }

  /**
   * Indirect boolean value checking can cause
   * unexpected result, that's why I am using direct
   * checking here.
   *
   */

  function isTrue(v) {
    return Object.is(v, true);
  }

  function isFalse(v) {
    return Object.is(v, false);
  }

  /*</>*/

  function isCallable(fn) {
    return typeof fn == "function";
  }

  function isAtag(tag) {
    return tag instanceof HTMLElement;
  }

  function isANode(target) {
    return isDefined(target) && (target.nodeType == 1 || target.nodeType == 3);
  }

  function validDomEvent(eventName) {
    return eventName in HTMLElement.prototype;
  }

  function validStyleName(styeName) {
    return styeName in document.createElement("p").style;
  }

  function createText(text) {
    return document.createTextNode(text);
  }

  function validTagOption(option) {
    return typeof option == "string";
  }

  function validStylesOrEventsOptions(option) {
    return isObj(option);
  }

  function getId(id) {
    if (typeof id !== "string") {
      syErr(`
            
            The value of the id attribute must be a string.
            
            `);
    }

    const el = document.getElementById(id);

    if (el == void 0) {
      err(`
            
            There's not an element on the document with the id	
			attribute whose value is "${id}".
    
            `);
    } else {
      return el;
    }
  }

  function valueType(val) {
    if (
      typeof val == "undefined" ||
      typeof val == "symbol" ||
      typeof val == "bigint" ||
      typeof val == "boolean" ||
      typeof val == "function" ||
      typeof val == "number" ||
      typeof val == "string"
    ) {
      return typeof val;
    } else {
      /**
       *
       * @val may be an array, a plain object or even
       * a native Javascript object,
       * let's check with the type() function.
       *
       */

      return type(val);
    }
  }

  // WARNINGS HELPERS

  function syErr(err) {
    throw new SyntaxError(`
        
        Inter syntaxError : ${err}
        
        `);
  }

  function err(e) {
    throw new Error(`
        
        Inter error: ${e}
        
        `);
  }

  function consW(w) {
    console.warn(`
        Inter warning: ${w}
        
        `);
  }

  function ParserWarning(w) {
    console.error(`
    
       Inter parser error: ${w}
        
        `);
  }

  //

  function isArray(arg) {
    return Array.isArray(arg);
  }

  function type(val) {
    // All Javascript objects.

    const isAnobject =
      isDefined(val) &&
      Object.prototype.toString.call(val).startsWith("[object");

    if (isAnobject) {
      return Object.prototype.toString
        .call(val)
        .replace("[object", "")
        .replace("]", "")
        .replace(/\s/g, "")
        .toLowerCase();
    } else {
      /**
       * @val is null.
       *
       */

      return "null";
    }
  }

  function isBool(val) {
    /**
     *
     * Don't use typeof val==="boolean"; due to 1 and 0.
     *
     */

    return val == true || val == false;
  }

  //Just for renderList.

  function validInProperty(IN) {
    return typeof IN == "string";
  }

  function validEachProperty(each) {
    return (
      each instanceof Array ||
      isObj(each) ||
      each instanceof Map ||
      each instanceof Set ||
      typeof each === "number"
    );
  }

  function toIterable(data) {
    const iterable = {
      values: new Array(),
      type: void 0,
    };

    if (isArray(data)) {
      iterable.values = data;
      iterable.type = "array";
    } else if (isObj(data)) {
      iterable.values = Object.entries(data);
      iterable.type = "object";
    } else if (data instanceof Map) {
      data.forEach((value, key) => {
        iterable.values.push([key, value]);
      });

      iterable.type = "object";
    } else if (data instanceof Set) {
      iterable.values = Array.from(data);
      iterable.type = "set";
    } else if (typeof data === "number") {
      for (let i = 0; i < data; i++) {
        iterable.values.push(i);
      }

      iterable.type = "number";
    }

    return iterable;
  }

  function Iterable(data) {
    this.source = toIterable(data);
  }

  Iterable.prototype.each = function (callBack) {
    let index = -1;

    for (const data of this.source.values) {
      index++;

      callBack(data, index, this.source.type);
    }
  };

  //</>

  function runReservedRefNameWarning(refName) {
    consW(`${refName} is a reserved reference's name, use others names.`);
  }

  function hasProp(object) {
    return Object.keys(object).length > 0;
  }

  function hasRefs(text) {
    return /{\s*.*\s*}/.test(text);
  }

  function getRefs(text) {
    /**
     *
     * @text must be a string containing refs.
     *
     * This function is used in reference computation,
     * it helps Inter making an eficient reference computation.
     *
     */

    const ref = /{\s*(:?[\w-\s]+)\s*}/g;

    const refs = new Set();

    text.replace(ref, (plainRef) => {
      const refName = plainRef.replace("{", "").replace("}", "").trim();

      refs.add(refName);
    });

    return Array.from(refs);
  }

  /**
   *
   * We are considering them as special attributes
   * because we must not use the setAttribute method
   * to set them.
   *
   */

  const specialAttrs = new Set(["currentTime", "value"]);

  function refParser(p, refs, rparse) {
    function getTextNodes(el) {
      let _childNodes = new Set();

      if (el.hasChildNodes())
        for (let child of el.childNodes) {
          if (
            child.nodeType == 3 &&
            child.textContent.trim().length > 0 &&
            hasRefs(child.textContent)
          ) {
            _childNodes.add(child);
          }
        }

      return Array.from(_childNodes);
    }

    const children = p.getElementsByTagName("*");

    function rChild(parentNode) {
      function runRef(node) {
        for (let r in refs) {
          const pattern = new RegExp(`{\\s*${r}\\s*}`);

          if (
            !node.ref &&
            node.textContent.trim().length > 0 &&
            pattern.test(node.textContent)
          ) {
            const register = {
              target: node,
              text: node.textContent,
            };

            rparse.add(register);
          }
        }
      }

      if (parentNode.nodeType == 1) {
        for (let node of parentNode.childNodes) {
          if (node.hasChildNodes() && node.nodeType == 1) {
            rChild(node);
            continue;
          }

          runRef(node);
        }
      } else if (parentNode.nodeType == 3) {
        // Parsing the references
        // in the main container's
        // text nodes.

        runRef(parentNode);
      }
    }

    if (getTextNodes(p).length > 0) {
      for (let text of getTextNodes(p)) {
        rChild(text);
      }
    }

    for (const child of children) {
      const _register = {
        target: child,
        attrs: Object.create(null),
        refs: refs,
      };

      for (const attr of child.attributes) {
        for (const r in refs) {
          const pattern = new RegExp(`{\\s*${r}\\s*}`);
          if (pattern.test(attr.value)) {
            if (!specialAttrs.has(attr.name)) {
              _register.attrs[attr.name] = attr.value;
            } else {
              rparse.specialAttrs.add({
                target: child,
                attr: {
                  [attr.name]: attr.value,
                },
              });
            }
          }
        }
      }

      if (hasProp(_register.attrs)) {
        rparse.add(_register, true);

        // The true argument says to the parser
        // to register the reference as an attribute reference.
      }

      if (child.hasChildNodes()) {
        const nodes = child.childNodes;

        for (const node of nodes) {
          if (node.hasChildNodes()) {
            rChild(node);
            continue;
          }

          for (const r in refs) {
            const pattern = new RegExp(`{\\s*${r}\\s*}`);

            if (
              !node.ref &&
              node.textContent.trim().length > 0 &&
              pattern.test(node.textContent)
            ) {
              const register = {
                target: node,
                text: node.textContent,
              };

              rparse.add(register);
            }
          }
        }
      } else {
        const text = child.textContent;

        const register = {
          target: child,
          text: text,
        };

        for (let r in refs) {
          const pattern = new RegExp(`{\\s*${r}\\s*}`);

          if (!child.ref && pattern.test(text)) {
            rparse.add(register);
          }
        }
      }
    }

    rparse.update();
  }

  function Ref(obj) {
    if (new.target != void 0) {
      syErr(`
        
        Do not call the Ref function with the new keyword.

        `);
    } else {
      if (!isObj(obj)) {
        syErr(`
            
            The argument of the "Ref" must be a plain object.

            `);
      } else {
        const { in: IN, data } = obj;

        if (!(typeof IN === "string")) {
          syErr(`
                The value of the "in" property in the Ref function must be a string.
                
                `);
        }

        if (!isObj(data)) {
          syErr(`
                The value of the "data" property in the Ref funtion must be a plain Javascript object.
                
                `);
        }

        const reservedRefNames = new Set(["setRefs", "observe"]);

        for (const refName in data) {
          if (reservedRefNames.has(refName)) {
            runReservedRefNameWarning(refName);

            continue;
          }

          if (isCallable(data[refName])) {
            data[refName] = data[refName].call(data);
          }
        }

        const proxyTarget = Object.assign({}, data);
        const store = {
          attrs: new Set(), // Attribute reference.
          text: new Set(), // Text reference.
          specialAttrs: new Set(),
          observed: new Map(),
          refs: proxyTarget,
          add(setting, attr) {
            // if attr, the parser must register the reference
            // as an attribute reference.

            if (attr) {
              this.attrs.add(setting);

              if (!this.refs && setting.refs) {
                this.refs = setting.refs;
              }
            } else {
              this.text.add(setting);

              if (!this.refs && setting.refs) {
                this.refs = setting.refs;
              }
            }
          },

          updateSpecialAttrs() {
            for (let special of Array.from(this.specialAttrs)) {
              if (special.target.hasAttribute("value")) {
                special.target.removeAttribute("value");
              } else {
                if (special.target.hasAttribute("currentTime")) {
                  special.target.removeAttribute("currentTime");
                }
              }

              const sp = Object.entries(special.attr)[0];

              const refs = getRefs(sp[1]);

              for (let ref of refs) {
                const pattern = new RegExp(`{\\\s\*\(\:\?${ref}\)\\\s\*}`, "g");
                special.target[sp[0]] = sp[1].replace(pattern, this.refs[ref]);
              }
            }
          },
          update2() {
            // This is the attribute reference updater.

            for (const a_r of Array.from(this.attrs)) {
              let { target, attrs } = a_r;

              for (let [name, v] of Object.entries(attrs)) {
                const refNames = getRefs(v);

                for (let refName of refNames) {
                  if (refName in this.refs) {
                    const pattern = new RegExp(
                      `{\\\s\*\(\:\?${refName}\)\\\s\*}`,
                      "g"
                    );

                    v = v.replace(pattern, this.refs[refName]);
                  }
                }

                if (target.getAttribute(name) !== v) {
                  target.setAttribute(name, v);
                }
              }
            }
          },
          update() {
            // This is the text reference updater.

            if (this.text.size > 0) {
              for (const t_r of Array.from(this.text)) {
                let { target, text } = t_r;

                // Returns the ref's Names
                // in the string "text".
                const refNames = getRefs(text);

                for (const refName of refNames) {
                  if (refName in this.refs) {
                    const pattern = new RegExp(
                      `{\\\s\*\(\:\?${refName}\)\\\s\*}`,
                      "g"
                    );

                    if (isDefined(text)) {
                      text = text.replace(pattern, this.refs[refName]);
                    }
                  }
                }
                if (isDefined(text)) {
                  if (target.textContent !== text) {
                    target.textContent = text;
                  }
                }
              }
            }

            // After updating the text reference, let's update the
            // attribute reference.

            if (this.attrs.size > 0) {
              this.update2();
            }

            if (this.specialAttrs.size > 0) {
              this.updateSpecialAttrs();
            }
          },
        };

        refParser(getId(IN), proxyTarget, store);

        const reactor = new Proxy(proxyTarget, {
          set(t, k, v, p) {
            const oldValue = t[k];

            if (isCallable(v)) {
              v = v.call(p);

              Reflect.set(t, k, v, p);
            } else {
              Reflect.set(t, k, v, p);
            }

            if (store.observed.size == 1) {
              const callBack = store.observed.get("callBack");

              callBack(k, v, oldValue);
            }

            if (store.specialAttrs.has(k)) {
              store.updateSpecialAttrs();
            }

            if (!(k in t)) {
              // Dynamic ref.

              refParser(getId(IN), proxyTarget, store);
            } else {
              store.update();
              return true;
            }
          },

          get(...args) {
            return Reflect.get(...args);
          },
        });

        Object.defineProperties(reactor, {
          setRefs: {
            set(o) {
              if (isObj(o)) {
                const reservedRefNames = new Set(["setRefs", "observe"]);

                for (const [refName, refValue] of Object.entries(o)) {
                  if (reservedRefNames.has(refName)) {
                    runReservedRefNameWarning(refName);

                    continue;
                  }

                  const oldRefValue = data[refName];

                  if (isCallable(refValue)) {
                    proxyTarget[refName] = refValue.call(reactor);
                  } else {
                    proxyTarget[refName] = refValue;
                  }

                  if (store.observed.size == 1) {
                    const callBack = store.observed.get("callBack");

                    callBack(refName, refValue, oldRefValue);
                  }
                }

                store.update();
              }
            },
            enumerable: !1,
          },
          observe: {
            value(callBack) {
              if (!isCallable(callBack)) {
                syErr(`
                        
                        The argument of [Reference reactor].observe() must be a function.
                        
                        
                        `);
              }

              if (store.observed.size === 0) {
                store.observed.set("callBack", callBack);

                return true;
              }

              return false;
            },

            writable: !1,
            enumerable: !1,
          },
        });

        return reactor;
      }
    }
  }

  function getChildNodes(root) {
    const nodes = new Array();

    root.childNodes.forEach((node, index) => {
      if (
        node.nodeType == 1 ||
        (node.nodeType == 3 && !node.textContent.trim().length == 0)
      ) {
        if (node.index == void 0) {
          node.index = index;
        }

        nodes.push(node);
      }
    });

    return nodes;
  }

  function runReservedPropWarning(prop) {
    consW(
      `${prop} is a reserved property, you can not it use as a conditional property.`
    );
  }

  function renderIf(obj) {
    if (!isObj(obj)) {
      syErr(`
        
        The argument of renderIf must be a  plain Javascript object.
        
        `);
    }

    if (new.target !== void 0) {
      syErr(`
        
        renderIf is not a constructor, do not call it with
        the new keyword.
        
        `);
    } else {
      const { in: IN, data } = obj;

      if (!(typeof IN === "string")) {
        syErr(`
             The value of the "in" property in renderIf function must be a string.
            
            `);
      }

      if (!isObj(data)) {
        syErr(`
            The value of the "data" property in renderIf function must be a plain Javascript object.

            `);
      }

      const reservedProps = new Set(["setConds", "observe"]);
      const theContainer = getId(IN);
      const els = new Set();

      for (let [prop, value] of Object.entries(data)) {
        if (reservedProps.has(prop)) {
          runReservedPropWarning(prop);
          continue;
        }

        value = isCallable(value) ? value.call(data) : value;

        if (!isBool(value)) {
          err(`
                
                The value of a conditional property must be boolean(true/false),
                and the value of  "${prop}" property is not boolean.
                
                `);
        }

        data[prop] = value;
      }

      function parseAttrs(container) {
        let index = -1;
        const children = container.childNodes;

        for (const child of children) {
          index++;

          const setting = {
            target: child,
            if: void 0,
            else: void 0,
            ifNot: void 0,
            i: index,
            root: container,
          };

          child.index = index;

          if (child.nodeType == 3) continue;

          const sibling = child.nextElementSibling,
            previous = child.previousElementSibling;

          if (child.children.length > 0) {
            parseAttrs(child);
          }

          if (child.hasAttribute("_ifNot")) {
            if (child.hasAttribute("_if") && child.hasAttribute("_else")) {
              ParserWarning(`
                    The parser found an element with the _ifNot attribute and one more conditional attribute,
                    it's forbidden.
                    
                    `);
            }

            setting.ifNot = child.getAttribute("_ifNot");

            if (setting.ifNot in data) {
              child.removeAttribute("_ifNot");

              els.add(setting);
            } else {
              ParserWarning(`
                    
                    The conditional rendering parser found
                    an element with the _notIf attribute and the value
                    of this attribute is not a conditional property in data object.

                    {
                        element: ${child.nodeName.toLowerCase()},
                        _ifNot:${setting.ifNot},
                        data:${Object.keys(data)}
                    }
                    
                    `);
            }
          } else if (
            child.hasAttribute("_else") &&
            (!previous || !previous.if)
          ) {
            ParserWarning(`
                                
                The parser found an element with an "_else" attribute,
                but there is not an element with "_if" attribute before it.

                `);

            return false;
          }

          if (child.hasAttribute("_if")) {
            if (child.hasAttribute("_else")) {
              ParserWarning(`
                    
                    The parser found an element which has simultaneousylly
                    the "_if" and "_else" attribute. It's forbidden.
                    
                    `);

              return false;
            }

            setting.if = child.getAttribute("_if");
            child.removeAttribute("_if");
            child.if = true;

            if (!(setting.if in data)) {
              ParserWarning(`
                    
                    The conditional rendering parser found
                    an element with the _If attribute and the value
                    of this attribute is not a conditional property in data object.

                    {
                        element: ${child.nodeName.toLowerCase()},
                        _if:${setting.if},
                        data:${Object.keys(data)}
                    }
                    
                    `);

              setting.if = void 0;
            }
          }
          if (setting.if && sibling && sibling.hasAttribute("_else")) {
            if (sibling.hasAttribute("_if")) {
              ParserWarning(`
                    
                    The parser found an element which has simultaneousilly
                    the "_if" and "_else" attribute. It's forbidden.
                    
                    `);

              return false;
            }

            setting.else = sibling;
            sibling.removeAttribute("_else");
          }
          if (setting.if) {
            els.add(setting);
          }
        }
      }

      parseAttrs(theContainer);

      const reactor = runRenderingSystem(els, data);

      return reactor;
    }
  }

  function runRenderingSystem(els, data) {
    const toArray = Array.from(els);

    function run(source) {
      for (const el of toArray) {
        const { target, if: IF, else: ELSE, ifNot, i, root } = el;

        const current = getChildNodes(root)[i];

        if (ifNot) {
          if (isFalse(source[ifNot]) && !target.isSameNode(current)) {
            if (isANode(current) || root.textContent.trim().length !== 0) {
              insertBefore(root, target);
            } else {
              root.appendChild(target);
            }
          } else {
            if (target.parentNode == root && isTrue(source[ifNot])) {
              root.removeChild(target);
            }
          }
        } else if (isFalse(source[IF])) {
          if (target.parentNode == root && !ELSE) {
            root.removeChild(target);
          } else if (ELSE) {
            if (target.parentNode == root) {
              root.removeChild(target);
              insertBefore(root, ELSE);
            }
          }
        } else {
          if (current && current.isSameNode(target)) {
            if (ELSE && ELSE.parentNode != null) {
              root.removeChild(ELSE);
            }
          } else if (ELSE && ELSE.parentNode != null) {
            root.removeChild(ELSE);
            insertBefore(root, target);
          } else {
            insertBefore(root, target);
          }
        }
      }
    }

    function insertBefore(root, target) {
      const children = getChildNodes(root),
        lastChild = children[children.length - 1];

      if (target.parentNode == null) {
        if (lastChild && lastChild.index > target.index) {
          for (const child of children) {
            if (child.index > target.index) {
              root.insertBefore(target, child);

              break;
            }
          }
        } else {
          root.appendChild(target);
        }
      }
    }

    const reservedProps = new Set(["setConds", "observe"]);
    const observer = new Map();
    const proxyTarget = Object.assign({}, data);

    run(proxyTarget);

    const reactor = new Proxy(proxyTarget, {
      set(target, prop, value) {
        if (!(prop in data) && !reservedProps.has(prop)) {
          consW(`
            The "${prop}" was not defined 
            as a conditional property.
            
            `);

          return false;
        }

        if (!isBool(value) && !reservedProps.has(prop)) {
          err(`
                
            The value of a conditional property must be boolean(true/false),
            and the value of  "${prop}" property is not boolean.
            
            `);

          return false;
        }

        Reflect.set(target, prop, value);

        if (!reservedProps.has(prop)) {
          run(proxyTarget);

          if (observer.size == 1) {
            const callBack = observer.get("callBack");

            callBack(prop, value);
          }
        }

        return true;
      },

      deleteProperty(...args) {
        return false;
      },
    });

    Object.defineProperties(reactor, {
      observe: {
        value(fn) {
          if (!isCallable(fn)) {
            syErr(`
            The argument of [renderIf reactor].observe()
            must be a function.
            `);
          }

          if (observer.size == 0) {
            observer.set("callBack", fn);

            return true;
          }

          return false;
        },
        writable: !1,
        enumerable: !1,
      },
      setConds: {
        set(conditions) {
          if (!isObj(conditions)) {
            syErr(`
                
                The value of [renderIf reactor].setConds must be only
                a Javascript object, and you defined ${valueType(conditions)}
                as its value.

                `);
          }

          for (let [prop, cond] of Object.entries(conditions)) {
            if (reservedProps.has(prop)) {
              runReservedPropWarning(prop);
              continue;
            }

            cond = isCallable(cond) ? cond.call(data) : cond;

            if (!isBool(cond)) {
              err(`
                
                The value of a conditional property must be boolean(true/false),
                and the value of  "${prop}" property is not boolean.
                
                `);
            }

            if (!(prop in this)) {
              consW(`
                    
                    "${prop}" was not defined as conditional property.
                    
                    `);
            }

            proxyTarget[prop] = cond;
          }

          run(proxyTarget);
        },
        enumerable: !1,
      },
    });

    return reactor;
  }

  function runReservedAttrNameWarning(attrName) {
    consW(`${attrName} is a reserved Attribute's name.`);
  }

  function toAttrs(obj) {
    if (new.target !== void 0) {
      syErr(`
        toAttrs is not a constructor,
        do not call it with the "new" keyword.
        
        `);
    }

    if (!isObj(obj)) {
      syErr(`
        The argument of "toAttrs()" function must be an object.
        `);
    }

    const { in: IN, data } = obj;

    if (!(typeof IN == "string")) {
      syErr(`
    
    The "in" property value in toAttrs() function must be a string.
    
    `);
    }

    if (!isObj(data)) {
      syErr(`

    The "data" property value in toAttrs() function must be an object.
  
    `);
    }

    const root = getId(IN);

    return findAttrManager(root, data);
  }

  function findAttrManager(rootElem, attrManagers) {
    const keys = Object.getOwnPropertyNames(attrManagers);
    const children = rootElem.getElementsByTagName("*");
    const reactors = Object.create(null);

    for (const child of children) {
      if (child.attributes.length == 1) {
        const theAttr = child.attributes[0].name;

        for (const key of keys) {
          const pattern = new RegExp(`{...${key}}`);

          if (pattern.test(theAttr)) {
            child.removeAttribute(theAttr);

            const reactor = spread(child, key, attrManagers[key]);

            reactors[Object.keys(reactor)[0]] = Object.values(reactor)[0];
          } else {
            const isAnAttrManager = /{(:?\.){3}(:?[\s\S]+)}/.test(theAttr);
            const hasMoreThanThreeDots = /{(:?\.){4,}(:?[\s\S]+)}/.test(
              theAttr
            );
            const attr = theAttr.replace(/{(:?\.){3}/, "").replace("}", "");

            if (hasMoreThanThreeDots) {
              ParserWarning(`
                
                "${theAttr}" is an invalid syntax for attribute manager.
                The attribute manager must have only three dots.

                Ex: {...managername}
                
                `);
            }
            if (isAnAttrManager && !attrManagers.hasOwnProperty(attr)) {
              // The attribute manager <key> was not defined in toAttrs function,
              // but there is a reference to it in template.

              ParserWarning(`
            
            The attribute manager parser found a manager named "${attr}" but
            you did not defined it in the toAttrs function.
            
            `);
            }
          }
        }
      }
    }

    return reactors;
  }

  function spread(el, attrManager, attrs) {
    //We are considering them specials
    // because we can not reset them with the setAttribute function.
    const specialAttrs = new Set(["value", "currentTime"]);
    const reservedAttrsName = new Set(["setAttrs"]);

    function runUpdate(value, attrName) {
      value = isCallable(value) ? value.call(attrs) : value;

      if (value == void 0) {
        if (!attrName.startsWith("on")) {
          el.removeAttribute(attrName);
        } else {
          el[attrName] = void 0;
        }
      } else if (!attrName.startsWith("on") && !specialAttrs.has(attrName)) {
        el.setAttribute(attrName, value);
      } else if (specialAttrs.has(attrName)) {
        el[attrName] = value;
      } else {
        if (attrName.startsWith("On")) {
          if (validDomEvent(attrName)) {
            if (!isCallable(value)) {
              syErr(`
                        The value of the "${attrName}" event, must be a function.
                        `);
            }

            el[attrName] = function (e) {
              v.call(original, e);
            };
          } else {
            consW(`
                    
                    "${attrName}" doesn't seem to be a valid dom event.
                    
                    `);
          }
        }
      }
    }

    function defineReactivity(attrName) {
      Object.defineProperty(attrs, attrName, {
        set(v) {
          runUpdate(v, attrName);
        },

        get() {
          if (attrName.startsWith("on")) {
            consW(`
                       "${attrName}" seems to be an event listener, 
                       and you can not get the value of an event.
                       `);
          }
          if (!specialAttrs.has(attrName)) {
            return el.getAttribute(attrName);
          } else {
            return el[attrName];
          }
        },
      });
    }

    //<>//

    // Spreading the attributes.

    function spreadAttrs(attrName, attrValue) {
      if (reservedAttrsName.has(attrName)) {
        runReservedAttrNameWarning(attrName);
        return false;
      }

      attrValue = !attrName.startsWith("on")
        ? isCallable(attrValue)
          ? attrValue.call(attrs)
          : attrValue
        : attrValue;

      if (
        attrValue != void 0 &&
        !specialAttrs.has(attrName) &&
        !attrName.startsWith("on")
      ) {
        el.setAttribute(attrName, attrValue);
      } else if (attrValue != void 0 && specialAttrs.has(attrName)) {
        el[attrName] = attrValue;
      } else {
        if (attrName.startsWith("on")) {
          if (validDomEvent(attrName)) {
            if (!isCallable(attrValue)) {
              syErr(`
                    
                    The value of "${attrName}" must be a function.

                    `);
            }

            el[attrName] = function (e) {
              attrValue.call(attrs, e);
            };
          } else {
            syErr(`
                
                "${attrName}" doesn't seem to be a valid dom event.
                
                `);
          }
        }
      }
    }

    for (const [attrName, attrValue] of Object.entries(attrs)) {
      spreadAttrs(attrName, attrValue);
      defineReactivity(attrName);
    }

    //</>//

    Object.defineProperties(attrs, {
      setAttrs: {
        set(__attrs) {
          if (!isObj(__attrs)) {
            syErr(`
                    
                    The argument of [Attribute manager].setAttrs
                    must be an object.
                    
                    `);
          }

          for (const [attr, value] of Object.entries(__attrs)) {
            if (!(attr in this)) {
              consW(`
                        
                         The attribute manager "${attrManager}" 
                         does not manage an attribute named "${attr}",
                         all the attributes must be defined in the attrManager manager
                         object.
                        
                        `);

              continue;
            }

            if (reservedAttrsName.has(attr)) {
              runReservedAttrNameWarning(attr);

              continue;
            }

            this[attr] = value;
          }
        },
        enumerable: !1,
      },

      [Symbol.toStringTag]: {
        value: () => "Manager",
      },
    });

    return {
      [attrManager]: attrs,
    };
  }

  function template(obj) {
    if (isObj(obj)) {
      const temp = Symbol.for("template");

      return {
        [temp]: !0,
        element: obj,
      };
    } else {
      syErr(`
    
    The argument of the template function must be a plain Javascript object,
    but you defined "${valueType(obj)}" as its argument.
    
    `);
    }
  }

  function runInvalidStyleValue(name, value) {
    ParserWarning(`
	  "${value}" is an invalid value for the "${name}" property in the
	  "styles" object(template function).
	  `);
  }

  function toDOM(obj, isChild, index) {
    let {
      tag,
      text,
      renderIf,
      attrs = {},
      events = {},
      styles = {},
      children = [],
    } = obj;

    tag = isCallable(tag) ? tag() : tag;
    text = isCallable(text) ? text() : text;

    if (isDefined(renderIf) && !isChild) {
      ParserWarning(`
              
              You can not conditionally render a container in template
              function.
              
              `);

      return false;
    }

    if (!validTagOption(tag)) {
      syErr(`
                
                "${valueType(
                  tag
                )}" is an invalid tag name, in template function.
                
                `);
    }

    if (
      !validStylesOrEventsOptions(events) ||
      !validStylesOrEventsOptions(styles)
    ) {
      syErr(`
                
                The "events" and "styles" options in template function must be both plain Javascript objects.               
                `);
    }

    const container = document.createElement(tag);
    container.template = Object.assign(obj, {
      target: container,
      tag: tag,
      text: text,
    }); // For diffing task.

    if (isChild) {
      container.index = index;
    }

    Object.entries(attrs).forEach((attr) => {
      let [name, value] = attr;

      const setAttr = (attrValue) => {
        const isPecialAttr = () => {
          const specialAttrs = new Set(["value", "currentTime"]);

          return specialAttrs.has(name);
        };

        if (isDefined(attrValue) && !isFalse(attrValue)) {
          if (!isPecialAttr()) {
            container.setAttribute(name, attrValue);
          } else {
            container[name] = attrValue;
          }
        }

        container.template.attrs[name] = attrValue;
      };

      if (isCallable(value)) {
        value = value();

        setAttr(value);
      } else {
        setAttr(value);
      }
    });

    Object.entries(events).forEach((event) => {
      const [name, handler] = event;

      if (validDomEvent(name)) {
        if (isCallable(handler)) {
          container[name] = handler;
        } else {
          consW(`
		  The "${name}" event was not created, because its handler
		  is not a function.
		  
		  You defined "${handler}" as the value 
		  of the "${name}" event.
		  `);
        }
      } else {
        ParserWarning(`
                        
                        "${name}" doesn't seem to be a valid dom event.
                        
                        `);
      }
    });

    Object.entries(styles).forEach((style) => {
      const [name, value] = style;

      if (validStyleName(name)) {
        let styleValue = isCallable(value) ? value() : value;

        if (isDefined(styleValue)) {
          container.style[name] = styleValue;
        }

        if (container.style[name] !== styleValue && isDefined(styleValue))
          runInvalidStyleValue(name, styleValue);

        container.template.styles[name] = styleValue;
      } else {
        ParserWarning(`
                    
                    "${name}" doesn't seem to be a valid style name.

                    `);
      }
    });

    if (isDefined(text) && children.length == 0) {
      const textContent = createText(text);

      if (isDefined(textContent)) container.appendChild(textContent);
    } else if (isDefined(text) && children.length > 0) {
      consW(`
                    
                    It was found an element with both the text property and children property,
                    and in this case Inter ignores the text property.
                    
                    `);

      createChildren(container, children);
    } else {
      if (children.length > 0) {
        createChildren(container, children);
      }
    }

    return container;
  }

  function createChildren(root, children) {
    let index = -1;

    for (const child of children) {
      let {
        tag,
        text,
        attrs = {},
        events = {},
        styles = {},
        children = [],
        renderIf,
      } = child;

      index++;
      child.index = index;
      tag = isCallable(tag) ? tag() : tag;
      text = isCallable(text) ? text() : text;

      if (isDefined(renderIf) && isBool(renderIf)) {
        if (isFalse(renderIf)) {
          continue;
        }
      }

      if (isDefined(renderIf) && !isBool(renderIf)) {
        consW(`
            
            The value of the renderIf property must be only boolean(true/false), in template 
            function.
            
            `);
      }

      if (!validTagOption(tag)) {
        syErr(`
            
            "${tag}" is an invalid tag name, in template function.
            
            `);
      }

      if (
        !validStylesOrEventsOptions(events) ||
        !validStylesOrEventsOptions(styles)
      ) {
        syErr(`
            
            The "events" and "styles" options in template function must be both plain Javascript objects.               
            `);
      }

      const container = document.createElement(tag);
      container.index = index;
      container.template = Object.assign(child, {
        target: container,
        tag: tag,
        text: text,
      }); //For diffing task.

      Object.entries(attrs).forEach((attr) => {
        let [name, value] = attr;

        const setAttr = (attrValue) => {
          const isPecialAttr = () => {
            const specialAttrs = new Set(["value", "currentTime"]);

            return specialAttrs.has(name);
          };

          if (isDefined(attrValue) && !isFalse(attrValue)) {
            if (!isPecialAttr()) {
              container.setAttribute(name, attrValue);
            } else {
              container[name] = attrValue;
            }
          }
        };

        if (isCallable(value)) {
          value = value();

          setAttr(value);
        } else {
          setAttr(value);
        }

        container.template.attrs[name] = value;
      });

      Object.entries(events).forEach((event) => {
        const [name, handler] = event;

        if (validDomEvent(name)) {
          if (isCallable(handler)) {
            container[name] = handler;
          } else {
            consW(`
		  The "${name}" event was not created, because its handler
		  is not a function.
		  
		  You defined "${handler}" as the value 
		  of the "${name}" event.
		  `);
          }
        } else {
          ParserWarning(`
                    
                    "${name}" doesn't seem to be a valid dom event.
                    
                    `);
        }
      });

      Object.entries(styles).forEach((style) => {
        const [name, value] = style;

        if (validStyleName(name)) {
          let styleValue = isCallable(value) ? value() : value;

          if (isDefined(styleValue)) {
            container.style[name] = styleValue;
          }

          if (container.style[name] !== styleValue && isDefined(styleValue))
            runInvalidStyleValue(name, styleValue);

          container.template.styles[name] = styleValue;
        } else {
          ParserWarning(`
                
                "${name}" doesn't seem to be a valid style name.

                `);
        }
      });

      if (isDefined(text) && children.length == 0) {
        const textContent = isCallable(text)
          ? createText(text())
          : createText(text);

        if (isDefined(textContent)) container.appendChild(textContent);
      } else if (isDefined(text) && children.length > 0) {
        consW(`
                
                It was found an element with both the text property and children property,
                and in this case Inter ignores the text property.
                
                `);

        createChildren(container, children);
      } else {
        if (children.length > 0) {
          createChildren(container, children);
        }
      }

      root.appendChild(container);
    }
  }

  /**
   *  Reactive system for listing.
   *
   */

  function checkType(arg, call) {
    if (isObj(arg)) {
      defineReactiveObj(arg, call);
    } else if (isArray(arg)) {
      defineReactiveArray(arg, call);
    } else if (isMap(arg)) {
      defineReactiveMap(arg, call);
    } else {
      if (isSet(arg)) {
        defineReactiveSet(arg, call);
      }
    }
  }

  function exactElToRemove(obj, key, root) {
    if (isObj(obj)) {
      _inObj(obj, key, root);
    } else if (isSet(obj)) {
      _inSet(obj, key, root);
    } else {
      _inMap(obj, key, root);
    }
  }

  function _inObj(obj, key, root) {
    const keys = Object.keys(obj);

    keys.some((prop, i) => {
      if (prop == key) {
        _exactRemove(root, i);
      }
    });
  }

  function _inSet(set, key, root) {
    const obj = Array.from(set);

    obj.some((item, i) => {
      if (item == key) {
        _exactRemove(root, i);
      }
    });
  }

  function _inMap(obj, key, root) {
    let i = -1;

    obj.forEach((value, prop) => {
      i++;

      if (prop == key) {
        _exactRemove(root, i);
      }
    });
  }

  function _exactRemove(root, i) {
    const elToRmove = root.children[i];

    if (isAtag(elToRmove)) {
      root.removeChild(elToRmove);
    }
  }

  function createArrayReactor(each, updateSystem) {
    if (isNotConfigurable(each)) {
      err(`
        
        Inter fails to define the reactivity in the list reactor,
        because the array  of the each option is not configurable.
        
        `);
    }

    const costumProps = new Set(["otherArray", "addItems"]);

    return new Proxy(each, {
      set(target, prop, value) {
        if (costumProps.has(prop)) {
          Reflect.set(target, prop, value);
          return true;
        }

        Reflect.set(target, prop, value);

        updateSystem();

        if (typeof prop !== "number" && validEachProperty(value)) {
          checkType(value, updateSystem);
        }

        return true;
      },

      get(target, prop) {
        return target[prop];
      },
    });
  }

  function createObjReactor(each, updateSystem, root) {
    if (isNotConfigurable(each)) {
      err(`
        
        Inter fails to define the reactivity in the list reactor,
        because the array  of the each option is not configurable.
        
        `);
    }

    return new Proxy(each, {
      set(target, prop, value) {
        Reflect.set(target, prop, value);

        updateSystem();

        if (typeof prop !== "number" && validEachProperty(value)) {
          checkType(value, updateSystem);
        }

        return true;
      },

      get() {
        return Reflect.get(...arguments);
      },

      deleteProperty(target, prop) {
        if (prop in target) {
          exactElToRemove(target, prop, root);
          Reflect.deleteProperty(...arguments);
          updateSystem();

          return true;
        }

        consW(`
            You are trying to delete the "${prop}" property in the list
            reactor, but that property does not exist in the list reactor.
            
            `);
      },
    });
  }

  function defineReactiveObj(obj, call) {
    const reactive = Symbol.for("reactive"),
      reservedProps = new Set(["setProps", "defineProps", "deleteProps"]),
      share = Object.assign(Object.create(null), obj);

    if (reactive in obj) {
      //The object is already reactive
      //So, we must skip all the task.

      return false;
    }

    if (isNotConfigurable(obj)) {
      consW(`
        
        Inter fails to define reactivity
        in a plain Javascript object because it is a non-configurable object.
        
        `);

      return false;
    }

    for (const prop of Object.keys(obj)) {
      if (reservedProps.has(prop)) {
        delete obj[prop];

        consW(`
        
        "${prop}" is a reserved property,
        do not create a property with this name in the reactor
        of reactive listing.
        
        `);
      }

      Object.defineProperty(obj, prop, {
        set(newValue) {
          share[prop] = newValue;
          call();
          checkType(newValue, call);
        },

        get() {
          return share[prop];
        },
        configurable: !0,
      });

      checkType(obj[prop], call);
    }

    Object.defineProperties(obj, {
      defineProps: {
        set(props) {
          if (!isObj(props)) {
            syErr(`
                    
                    The value of [List reactor => Object.defineProps] must be
                    only a plain Javascript object, and you
                    defined "${valueType(props)}" as its value.
                    
                    `);
          }

          for (const [prop, value] of Object.entries(props)) {
            if (
              !(prop in this) &&
              prop !== "defineProps" &&
              prop !== "setProps" &&
              prop !== "dleteProps"
            ) {
              share[prop] = value;
              Object.defineProperty(this, prop, {
                set(newValue) {
                  share[prop] = newValue;
                  call();
                  checkType(newValue, call);
                },
                get() {
                  return share[prop];
                },
                configurable: !0,
              });

              checkType(value, call);
            }
          }

          call();
        },
        enumerable: !1,
      },

      setProps: {
        set(props) {
          if (!isObj(props)) {
            syErr(`
                    
                    The value of [Reactor].defineProps must be
                    only a plain Javascript object, and you
                    defined ${valueType(props)} as its value.
                    
                    `);
          }

          for (const [prop, value] of Object.entries(props)) {
            if (
              prop in this &&
              prop !== "defineProps" &&
              prop !== "setProps" &&
              prop !== "deleteProps"
            ) {
              share[prop] = value;
              checkType(value, call);
            }
          }

          call();
        },
        enumerable: !1,
      },
      deleteProps: {
        set(props) {
          if (!isArray(props)) {
            syErr(`
                    
                    The value of [List reactor => Object.deleteprops] must be 
                    an array, and you defined "${valueType(
                      props
                    )}" as its value.
                    
                    `);
          }

          for (const prop of props) {
            if (prop in this) {
              delete this[prop];
              delete share[prop];
            }
          }

          call();
        },
        enumerable: !1,
      },
      [reactive]: {
        get() {
          return true;
        },
      },
    });
  }

  function defineReactiveArray(array, call) {
    const reactive = Symbol.for("reactive");

    if (reactive in array) {
      return false;
    }

    const mutationMethods = [
      "push",
      "unshift",
      "pop",
      "shift",
      "splice",
      "sort",
      "reverse",
    ];

    for (const method of mutationMethods) {
      Object.defineProperty(array, method, {
        value(start, deleteCount, ...items) {
          Array.prototype[method].apply(this, arguments);
          call();

          if (method === "push" || method === "unshift") {
            for (const arg of arguments) {
              checkType(arg, call);
            }
          } else {
            if (method === "splice" && isDefined(items)) {
              for (const item of items) {
                checkType(item, call);
              }
            }
          }
        },
      });
    }

    walkArray(array, call);

    Object.defineProperty(array, reactive, {
      value: true,
    });
  }

  function defineReactiveMap(map, call, listReactor, root) {
    const reactive = Symbol.for("reactive");

    if (reactive in map) {
      return false;
    }

    const mutationMethods = ["set", "delete", "clear"];

    for (const method of mutationMethods) {
      Object.defineProperty(map, method, {
        value() {
          if (method == "delete" && listReactor)
            exactElToRemove(this, arguments[0], root);
          Map.prototype[method].apply(this, arguments);
          call();

          if (method == "set") {
            const value = arguments[1];

            checkType(value, call);
          }
        },
      });
    }

    walkMap(map, call);

    Object.defineProperty(map, reactive, {
      value: true,
    });
  }

  function defineReactiveSet(set, call, listReactor, root) {
    const reactive = Symbol.for("reactive");

    if (reactive in set) {
      return false;
    }

    const mutationMethods = ["add", "clear", "delete"];

    for (const method of mutationMethods) {
      Object.defineProperty(set, method, {
        value() {
          if (method == "delete" && listReactor)
            exactElToRemove(this, arguments[0], root);
          Set.prototype[method].apply(this, arguments);
          call();
          if (method === "add") {
            checkType(arguments[0], call);
          }
        },
      });
    }

    walkSet(set, call);

    Object.defineProperty(set, reactive, {
      value: true,
    });
  }

  function walkMap(map, call) {
    /**
     * The goal here is to iterate through the map collection
     * and if we found an object, an array, a set or even a map, we must make it reactive.
     *
     */

    map.forEach((value) => {
      checkType(value, call);
    });
  }

  function walkArray(array, call) {
    for (const item of array) {
      checkType(item, call);
    }
  }

  function walkSet(set, call) {
    set.forEach((value) => {
      checkType(value, call);
    });
  }

  const reactive = Symbol.for("reactive");

  function costumReactor(array, htmlEl, updateSystem, DO, pro) {
    if (isNotConfigurable(array)) {
      return false;
    }

    //It is already reactive array.
    if (reactive in array) {
      return false;
    }

    // Is not returning the template.
    function runError() {
      syErr(`
                
        You are not returning the template function
        in the "do" method, renderList, you must return
        the template function.
        
        `);
    }

    Object.defineProperties(array, {
      shift: {
        value() {
          const ArrayPrototypeShiftReturn = Array.prototype.shift.apply(
            array,
            void 0
          );
          const firstNodeElement = htmlEl.children[0];

          if (firstNodeElement) {
            htmlEl.removeChild(firstNodeElement);

            updateSystem();
          }

          return ArrayPrototypeShiftReturn;
        },
      },

      unshift: {
        value() {
          const ArrayPrototypeUnshiftReturn = Array.prototype.unshift.apply(
            array,
            arguments
          );

          if (arguments.length > 1) {
            let i = arguments.length - 1;

            for (; i > -1; i--) {
              const temp = DO.call(pro, arguments[i], i, pro);

              if (!isValidTemplateReturn(temp)) {
                runError();
              }
              if (htmlEl.children[0]) {
                htmlEl.insertBefore(toDOM(temp.element), htmlEl.children[0]);
              } else {
                htmlEl.appendChild(toDOM(temp.element));
              }

              checkType(arguments[i], updateSystem);
            }
          } else if (arguments.length == 1) {
            const temp = DO.call(pro, arguments[0], 0, pro);

            if (!isValidTemplateReturn(temp)) {
              runError();
            }

            if (htmlEl.children[0]) {
              htmlEl.insertBefore(toDOM(temp.element), htmlEl.children[0]);
            } else {
              htmlEl.appendChild(toDOM(temp.element));
            }

            checkType(arguments[0], updateSystem);
          }

          updateSystem();

          return ArrayPrototypeUnshiftReturn;
        },
      },
      splice: {
        value(start, deleteCount, ...items) {
          const ArrayPrototypeSpliceReturn = Array.prototype.splice.apply(
            array,
            arguments
          );

          if (items.length == 0) {
            let from = start;
            const to = deleteCount;

            /**
             * 4
             * 1
             *
             */
            for (let i = 0; i < to; i++) {
              const node = htmlEl.children[from];

              if (node) {
                htmlEl.removeChild(node);
              }
            }
          } else {
            if (deleteCount == 0 && items) {
              for (let l = items.length - 1; l > -1; l--) {
                const temp = DO.call(pro, items[l], l, pro);

                checkType(items[l], updateSystem);

                if (!isValidTemplateReturn(temp)) {
                  runError();
                }

                if (htmlEl.children[start]) {
                  htmlEl.insertBefore(
                    toDOM(temp.element),
                    htmlEl.children[start]
                  );
                } else {
                  htmlEl.appendChild(toDOM(temp.element));
                }
              }
            }
          }

          updateSystem();

          return ArrayPrototypeSpliceReturn;
        },
      },
      [reactive]: { value: true },
    });
  }

  function renderList(options) {
    if (new.target !== void 0) {
      syErr(`
        
        renderList is not a constructor, do not call
        it with the "new" keyword.
        
        `);
    }

    if (!isObj(options)) {
      syErr(`
        
        The options(the argument of renderList) must be a plain Javascript object.
        
        `);
    }

    let { in: IN, each, do: DO } = options;

    const root = getId(IN);

    if (!validInProperty(IN)) {
      syErr(`
        
        The "in" option in renderList must be a string.
        
        `);
    }

    if (!validEachProperty(each)) {
      syErr(`
  
        "${valueType(
          each
        )}" is not a valid value for the "each" option in renderList.
        The value that are accepted in "each" option, are:

        Array.
        Plain js object.
        Map.
        Set.

         
        `);
    }

    if (!isCallable(DO)) {
      syErr(`
        
        The value of the "do" option in renderList, must be only a function.
        
        `);
    }

    let pro,
      firstRender = true;

    function proSetup() {
      if (isArray(each)) {
        pro = createArrayReactor(each, updateSystem);

        costumReactor(each, root, updateSystem, DO, pro);
      } else if (isObj(each)) {
        pro = createObjReactor(each, updateSystem, root);
      } else if (isSet(each)) {
        defineReactiveSet(each, updateSystem, true, root);
        pro = each;
      } else {
        if (isMap(each)) {
          defineReactiveMap(each, updateSystem, true, root);
          pro = each;
        }
      }
    }

    const defineNewEach = (newArray) => {
      each = newArray;
      defineReactorReactiveProps(each, updateSystem);
      proSetup();
      updateSystem();
    };

    function defineReactorReactiveProps() {
      const reactive = Symbol.for("reactive");

      if (reactive in each) {
        return false;
      }

      Object.defineProperties(each, {
        otherArray: {
          set(value) {
            if (!isArray(value)) {
              syErr(
                `The value of [List reactor].otherArray property must be an Array.`
              );
            }

            defineNewEach(value);

            for (const item of value) {
              checkType(item, updateSystem);
            }
          },

          configurable: !0,
          enumerable: !1,
        },
        addItems: {
          value(items, position) {
            if (isDefined(position) && typeof position !== "number") {
              syErr(`
                        
                        The second argument of [LIST REACTOR].addItems must 
                        be a number.
                        
                        `);
            }

            if (!isArray(items)) {
              syErr(`
                        
                        The first argument of [LIST REACTOR ].addItems must be an Array.
                        
                        `);
            }

            if (!isDefined(position) || position > this.length - 1) {
              for (const item of items) {
                this.push(item);

                checkType(item, updateSystem);
              }

              /**
               * The reactive system does not track calls to
               * the Array.prototype.push, so calling only
               * Array.prototype.push will not trigger any update.
               *
               */

              updateSystem();
            } else if (position == 0 || position < 0) {
              for (let i = items.length - 1; i > -1; i--) {
                this.unshift(items[i]);

                checkType(items[i], updateSystem);
              }
            } else {
              for (let i = items.length - 1; i > -1; i--) {
                this.splice(position, 0, items[i]);

                checkType(items[i], updateSystem);
              }
            }
          },
          configurable: !0,
          enumerable: !1,
          writable: !1,
        },
      });
    }

    if (isArray(each)) {
      defineReactorReactiveProps();
    }

    proSetup();

    function updateSystem() {
      const i = new Iterable(each);

      syncronizeRootChildrenLengAndSourceLength(root, i);

      i.each((data, index, type) => {
        let newTemp;

        function checkIterationSourceType() {
          if (type === "array") {
            newTemp = DO.call(pro, data, index, pro);
          } else if (type === "object") {
            newTemp = DO.call(pro, data[0] /*prop*/, data[1] /*value*/, pro);
          } else if (type === "number") {
            newTemp = DO(data);
          } else {
            //The type is set.

            newTemp = DO.call(pro, data, pro);
          }
        }

        checkIterationSourceType();

        // The  function is returning the template.
        if (isValidTemplateReturn(newTemp)) {
          const actualEl = root.children[index];

          if (!isAtag(actualEl)) {
            root.appendChild(toDOM(newTemp.element));
          } else {
            if (!actualEl.template) {
              consW(`
                    
                    Avoid manipulating what Inter manipulates.
                    
                    `);

              /**
               * ActualEl was not rendered by Inter, in
               * this case we must replace it with an element
               * rendered by Inter to avoid diffing problems.
               */

              root.replaceChild(toDOM(newTemp.element), actualEl);
            } else {
              runDiff(newTemp.element, actualEl.template, actualEl);
            }
          }

          if (firstRender) {
            checkType(
              type !== "object" ? data : data[1] /*obj prop*/,
              updateSystem
            );
          }
        } else {
          syErr(`
            
           The template function is not being returned inside the "do" method in
           renderList(reactive listing), just return the template function.
            
            `);
        }
      });
    }

    updateSystem();

    firstRender = false;

    return pro;
  }

  function runDiff(newTemp, oldTemp, oldRoot) {
    /**
     * the update and the UpdateChildren
     * have high priority in the diffing.
     *
     */

    const diff = {
      children: true,
    };

    ContainerDeffing(newTemp, oldTemp, diff);

    if (diff.children && newTemp.children && newTemp.children.length > 0) {
      diffingChildren(newTemp.children, oldTemp.children, oldRoot);
    }
  }

  function getValue(text) {
    if (typeof text === "function") {
      text = text();
    }

    return text;
  }

  function isOneAnArrayAndOtherNot(first, second) {
    return (
      (isArray(first) && !isArray(second)) ||
      (!isArray(first) && isArray(second))
    );
  }

  function AreBothArray(first, second) {
    return isArray(first) && isArray(second);
  }

  function ContainerDeffing(newContainer, oldContainer, diff) {
    const {
      attrs: newAttrs = {},
      events: newEvents = {},
      styles: newStyles = {},
      children: newChildren,
    } = newContainer;

    const {
      attrs: oldAttrs = {},
      events: oldEvents = {},
      styles: oldStyles = {},
      children: oldChildren,
      target,
    } = oldContainer;

    const rootEL = target.parentNode;
    const newText = getValue(newContainer.text);
    const oldText = getValue(oldContainer.text);
    const newTag = getValue(newContainer.tag);
    const oldTag = getValue(oldContainer.tag);

    if (newTag !== oldTag) {
      const newElement = toDOM(newContainer);

      rootEL.replaceChild(newElement, target);

      diff.children = false;

      shareProps(oldContainer, newContainer);
      oldContainer.target = newElement;

      return true;
    }

    if (isOneAnArrayAndOtherNot(newChildren, oldChildren)) {
      const newElement = toDOM(newContainer);

      rootEL.replaceChild(newElement, target);

      diff.children = false;
      shareProps(oldContainer, newContainer);
      oldContainer.target = newElement;

      return true;
    }

    if (
      AreBothArray(newChildren, oldChildren) &&
      newChildren.length !== oldChildren.length
    ) {
      const newElement = toDOM(newContainer);

      rootEL.replaceChild(newElement, target);

      diff.children = false;
      shareProps(oldContainer, newContainer);
      oldContainer.target = newElement;

      return true;
    }

    if (!isDefined(newChildren) && !isDefined(oldChildren)) {
      if (newText !== oldText) {
        target.textContent = newText;

        oldContainer.text = newText;
      }
    }

    attributeDiffing(target, oldAttrs, newAttrs);
    eventDeffing(target, oldEvents, newEvents);
    styleDiffing(target, oldStyles, newStyles);
  }

  function shareProps(target, source) {
    Object.assign(target, source);
  }

  function getGreater(firstArray, secondArray) {
    return firstArray.length > secondArray.length ? firstArray : secondArray;
  }

  function attributeDiffing(target, oldAttributes, newAttributes) {
    function removeAttr(attr) {
      if (target.hasAttribute(attr)) {
        target.removeAttribute(attr);
      } else if (specialAttrs.has(attr)) {
        target[attr] = "";
      }

      if (attr == "checked" && target.checked) target.checked = false;
    }

    const _old = Object.keys(oldAttributes),
      _new = Object.keys(newAttributes),
      _greater = getGreater(_old, _new),
      specialsAttrs = new Set(["value", "current"]);

    for (let i = 0; _greater.length > i; i++) {
      const oldAttr = _old[i],
        newAttr = _new[i],
        oldAttrValue = getValue(oldAttributes[oldAttr]),
        newAttrValue = getValue(newAttributes[newAttr]);

      if (!(oldAttr in newAttributes)) {
        removeAttr(oldAttr);
      } else if (!isDefined(newAttrValue) || isFalse(newAttrValue)) {
        removeAttr(newAttr);
      } else if (isDefined(newAttrValue) && !isFalse(newAttrValue)) {
        if (newAttrValue !== oldAttrValue) {
          if (specialAttrs.has(newAttr)) target[newAttr] = newAttrValue;
          else target.setAttribute(newAttr, newAttrValue);

          if (newAttr == "checked" && !target.checked) target.checked = true;
        }
      }

      oldAttributes[oldAttr] = newAttrValue;
    }
  }

  function styleDiffing(target, oldStyles, newStyles) {
    const _old = Object.keys(oldStyles),
      _new = Object.keys(newStyles),
      _greater = getGreater(_old, _new);

    for (let i = 0; _greater.length > i; i++) {
      const oldStyle = _old[i],
        newStyle = _new[i],
        oldStyleValue = getValue(oldStyles[oldStyle]),
        newStyleValue = getValue(newStyles[newStyle]);

      if (!(oldStyle in newStyles) || !isDefined(newStyleValue)) {
        const styleV = target.style[oldStyle];
		const styleAttr = target.getAttribute("style");
        if (isDefined(styleV) && styleV.trim().length !== 0) {
          target.style[oldStyle] = null;
        }

        if (styleAttr && styleAttr.trim().length == 0) {
          target.removeAttribute("style");
        }
      } else if (isDefined(newStyleValue)) {
        if (newStyleValue !== oldStyleValue) {
          if (validStyleName(newStyle)) {
            target.style[newStyle] = newStyleValue;

            if (target.style[newStyle] !== newStyleValue)
              runInvalidStyleValue(newStyle, newStyleValue);
          } else {
            ParserWarning(`
        
        "${newStyle}" doesn't seem to be a valid style name.
        
        `);
          }
        }
      }

      oldStyles[oldStyle] = newStyleValue;
    }
  }

  function eventDeffing(target, oldEvents, newEvents) {
    const _old = Object.keys(oldEvents),
      _new = Object.keys(newEvents),
      _greater = getGreater(_old, _new);

    for (let i = 0; _greater.length > i; i++) {
      const oldEvent = _old[i],
        newEvent = _new[i];

      if (!(oldEvent in newEvents) || !isDefined(newEvents[oldEvent])) {
        target[oldEvent] = void 0;
      }

      if (!isCallable(newEvents[newEvent]) && validDomEvent(newEvent)) {
        target[oldEvent] = void 0;
        consW(`
		  The "${newEvent}" event was not created, because its handler
		  is not a function.
		  
		  You defined "${newEvents[newEvent]}" as the value 
		  of the "${newEvent}" event.
		  `);

        continue;
      }

      if (isDefined(newEvents[newEvent])) {
        if (validDomEvent(newEvent)) {
          target[newEvent] = newEvents[newEvent];
        } else {
          ParserWarning(`
        
        "${newEvent}" doesn't seem to be a valid dom event.
        
        `);
        }
      }
    }
  }

  function insertBefore(root, index, virtualElement) {
    for (let i = 0; i < root.children.length; i++) {
      const realElement = root.children[i];
      if (realElement.index > index) {
        root.insertBefore(virtualElement, realElement);
        break;
      }
    }
  }

  function diffingChildren(__new, __old, realParent) {
    const _new = Array.from(__new),
      _old = Array.from(__old);

    for (let i = 0; i < _new.length; i++) {
      /**
       * {tag:"h2"}  {tag:"h2"}
       * {tag:null} {tag:null}
       * {tag:"button"} {tag:"button"}
       *
       */

      const newChild = _new[i],
        oldChild = _old[i];
      let hasChildren = false;

      const {
        children: newChildren = [],
        events: newEvents = {},
        attrs: newAttrs = {},
        styles: newStyles = {},
        renderIf: newRenderIf,
      } = newChild;

      const {
        children: oldChildren = [],
        events: oldEvents = {},
        attrs: oldAttrs = {},
        styles: oldStyles = {},
        target,
        index,
      } = oldChild;

      let theLastElement;
      const newText = getValue(newChild.text);
      const oldText = getValue(oldChild.text);
      const newTag = getValue(newChild.tag);
      const oldTag = getValue(oldChild.tag);

      if (realParent) {
        theLastElement = realParent.children[realParent.children.length - 1];
      }

      if (newChildren.length !== oldChildren.length) {
        if (target && target.parentNode != null) {
          const newElement = toDOM(newChild, true, index);

          realParent.replaceChild(newElement, target);

          Object.assign(oldChild, newChild);
          oldChild.target = newElement;
        }

        continue;
      } else {
        if (newTag !== oldTag) {
          const newELement = toDOM(newChild, true, index);

          Object.assign(oldChild, newChild);

          if (target && target.parentNode != null) {
            realParent.replaceChild(newELement, target);
            oldChild.target = newELement;
          }

          continue;
        }

        if (isFalse(newRenderIf)) {
          if (target && target.parentNode != null) {
            realParent.removeChild(target);
          }
        }

        if (isTrue(newRenderIf)) {
          if (target && target.parentNode == null) {
            const newELement = toDOM(newChild, true, index);

            Object.assign(oldChild, newChild);

            oldChild.target = newELement;

            if (theLastElement && theLastElement.index > index) {
              insertBefore(realParent, index, newELement);
            } else {
              realParent.appendChild(newELement);
            }

            continue;
          }

          if (!target) {
            if (theLastElement && theLastElement.index > index) {
              const newELement = toDOM(newChild, true, index);

              Object.assign(oldChild, newChild);

              oldChild.target = newELement;

              insertBefore(realParent, index, newELement);
            } else {
              const newELement = toDOM(newChild, true, index);

              Object.assign(oldChild, newChild);

              oldChild.target = newELement;

              realParent.appendChild(newELement);
            }
          }
        }

        if (
          newChildren.length == oldChildren.length &&
          newChildren.length !== 0
        ) {
          hasChildren = true;
          diffingChildren(newChildren, oldChildren, target);
        }

        if (oldText !== newText && target && !hasChildren) {
          target.textContent = newText;
          oldChild.text = newText;
        }

        oldChild.tag = newTag;

        if (target) {
          attributeDiffing(target, oldAttrs, newAttrs);
          styleDiffing(target, oldStyles, newStyles);
          eventDeffing(target, oldEvents, newEvents);
        }
      }
    }
  }

  function syncronizeRootChildrenLengAndSourceLength(root, iterable) {
    if (root.children.length > iterable.source.values.length) {
      let length = root.children.length - iterable.source.values.length;

      while (length--) {
        root.removeChild(root.children[length]);
      }
    }
  }

  function toObj(obj) {
    /**
     * We will try to convert obj(if it's actually a JSON Object) to a plain object,
     * if it fails we must return the obj parameter.
     *
     */

    if (obj !== void 0) {
      try {
        return JSON.parse(obj);
      } catch (e) {
        return obj;
      }
    }
  }

  function openRequest(req, method, path, username, userpassword) {
    req.open(method, path, true, username, userpassword);
  }

  function Backend() {
    if (new.target === void 0) {
      err(`Backend is a constructor, call it with the new keyword.`);
    }
  }

  Backend.prototype = {
    get [Symbol.toStringTag]() {
      return "Ajax";
    },

    request(obj) {
      if (!isObj(obj)) {
        syErr(`
        
        The argument of [Backend instance].request method
        must be only an object, and you defined "${valueType(obj)}"
        as its argument.
        
        `);
      }

      const {
        type,
        path,
        events = {},
        timeout,
        withCredentials,
        body = null,
        headers = {},
        security,
      } = obj;

      if (!isDefined(type) || typeof type !== "string") {
        syErr(`
        
        You must define the type(method) of request, in Ajax with the "type" option and
        it must be a string.
        
        `);
      }

      if (!isDefined(path) || typeof path !== "string") {
        syErr(`
        
        You must define the path where the request will be sent, with the "path" option and 
        it must be a string.
        
        `);
      }

      const reactorHandler = new Map();
      let requestOpened = false;

      function call() {
        const req = new XMLHttpRequest();
        const method = type.toUpperCase();
        const allowedEvents = new Set(["onprogress", "ontimeout", "onabort"]);

        const _AjaxResponse = {
          get status() {
            return req.status;
          },

          get statusText() {
            return req.statusText;
          },

          get headers() {
            return req.getAllResponseHeaders();
          },

          get data() {
            return toObj(req.responseText);
          },

          get [Symbol.toStringTag]() {
            return "AjaxResponse";
          },

          isObj() {
            try {
              JSON.parse(req.responseText);

              return true;
            } catch (e) {
              return false;
            }
          },
        };

        if (isObj(security) && Object.keys(security).length >= 2) {
          if (security.username && security.password) {
            openRequest(
              req,
              method,
              path,
              security.username,
              security.password
            );

            requestOpened = true;
          } else {
            consW(`
               
                Invalid "security" object, security object must have the username and passoword 
                properties.
                
                `);
          }
        }

        if (!requestOpened) {
          openRequest(req, method, path);

          requestOpened = true;
        }

        if (!isObj(headers)) {
          syErr(`
           
           the "headers" property must be an object, and
           you defined it as : ${valueType(headers)}.
           
           `);
        }

        Object.entries(headers).forEach(([header, value]) => {
          req.setRequestHeader(header, value);
        });

        Object.entries(events).forEach(([name, handler]) => {
          if (allowedEvents.has(name)) {
            if (name !== "onprogress") {
              req[name] = () => {
                handler();
              };
            } else {
              req.onprogress = (ev) => {
                const Arg = {
                  abort: () => req.abort(),
                  progress: (ev.loaded * 100) / ev.total,
                };

                handler(Arg);
              };
            }
          } else {
            consW(`
            
            There's not any event named "${name}" in Ajax request.
            
            `);
          }
        });

        req.onreadystatechange = function () {
          if (this.readyState == 4) {
            if (this.status == 200) {
              if (reactorHandler.has("okay")) {
                reactorHandler.get("okay")(_AjaxResponse);
              }
            } else {
              if (reactorHandler.has("error")) {
                reactorHandler.get("error")(_AjaxResponse);
              }
            }
          }
        };

        if (typeof withCredentials == "boolean") {
          req.withCredentials = withCredentials;
        }

        if (typeof timeout == "number") {
          req.timeout = timeout;
        }

        req.send(body);
      }

      const reactors = {
        okay(fn) {
          if (!isCallable(fn)) {
            syErr(`
                
                The argument of okay method must be a function
                and you defined ${valueType(fn)} as its argument
                
                `);
          }

          reactorHandler.set("okay", fn);
          //Starting the request...
          call();
        },

        error(fn) {
          if (!isCallable(fn)) {
            syErr(`
                
                The argument of error method must be a function, and you
                defined ${valueType(fn)} as its argument.
                
                `);
          }

          reactorHandler.set("error", fn);
          //Starting the request...
          call();
        },

        response(okay, error) {
          if (arguments.length < 2) {
            syErr(`
                
                The response method must have two arguments and you only
                defined ${arguments.length}.
                
                `);
          }
          if (!isCallable(okay) && !isCallable(error)) {
            syErr(`
                
                The two arguments of response method must be functions.
                
                
                `);
          }

          reactorHandler.set("okay", okay);
          reactorHandler.set("error", error);
          //Starting the request...
          call();
        },
      };

      return reactors;
    },
  };

  Object.freeze(Backend.prototype);

  window.Ref = Ref;
  window.renderIf = renderIf;
  window.toAttrs = toAttrs;
  window.renderList = renderList;
  window.template = template;
  window.Backend = Backend;

  console.log("The global version 2.0.13 of Inter was successfully loaded.");
})();
